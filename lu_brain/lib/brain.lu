/**
	Copyright Â© 2021 Oleh Ihorovych Novosad 
*/

///////////////////////////////////////////////////////////////////////////////
// Brain API

	Lu_Brain lu_brain__create(Lu_Mem mem, struct lu_brain_config config)
	{
		Lu_Brain_Config p_config = lu_brain_config__validate(&config);
		lu__user_assert(p_config, "Lu_Brain_Config validation failed");

		Lu_Mem brain_mem		= mem; 
		lu__user_assert(brain_mem, "Cannot create brain_mem. Not enough memory?");

		Lu_Brain self 		= (Lu_Brain) lu_mem__alloc(brain_mem, sizeof(struct lu_brain));
		lu__user_assert(self, "Cannot allocate Lu_Brain. Not enough memory?");
		
		self->brain_mem  	= brain_mem; 
		self->s_mem			= brain_mem;
		self->n_mem 		= brain_mem; 

		self->config 		= *p_config;
		self->recs 			= lu_arr__temp_create(p_config->recs_size, false);

		self->s 			= NULL;
		self->n 			= NULL;

		return self;
	}

	void lu_brain__destroy(Lu_Brain self)
	{
		lu__assert(self);
		lu__assert(self->brain_mem);
		lu__assert(self->s_mem);
		lu__assert(self->n_mem);

		lu__user_assert_void(self, "Lu_Brain is NULL");

		if (self->n) 
		{
			lu_n__destroy(self->n);
			self->n = NULL;
		}

		if (self->s) 
		{	
			lu_s__destroy(self->s);
			self->s = NULL;
		}

		Lu_Rec rec;
		if (self->recs)
			for (lu_size i = 0; i < lu_arr__count(self->recs); i++)
			{
				rec = (Lu_Rec) lu_arr__get(self->recs, i);

				if (rec)
					lu_rec_destroy(rec, self->brain_mem);
			}

		lu_arr__destroy(self->recs);

		lu_mem__free(self->brain_mem, (lu_p_byte) self);
	}

	void lu_brain__print_info(Lu_Brain self)
	{
		lu__user_assert_void(self, "Lu_Brain is NULL");
		lu__user_assert_void(self->brain_mem, "Lu_Mem is NULL");

		lu__debug("\n\n=========> Brain #%lu Info <=========", self->config.id);
		lu__debug("\nMemory allocated (bytes): %lu", lu_mem__preallocated(self->brain_mem));
		lu__debug("\nMemory used (bytes): %lu", lu_mem__used(self->brain_mem));

 		if (self->s)
 			lu_s__print_info(self->s);

 		// if (self->n)
 		// 		lu_n__print_info(self->n);
	}

	struct lu_brain_config lu_brain_config_get(Lu_Brain self)
	{
		lu__assert(self);

		return self->config;
	}

	Lu_Brain lu_brain__reconfig(Lu_Brain self, struct lu_brain_config config)
	{
		lu__user_assert(NULL, "Not implemented yet");
	}

	static lu_size lu_brain__rec_attach(Lu_Brain self, Lu_Rec rec)
	{
		lu__assert(self);
		lu__assert(rec);
		lu__assert(self->recs);
		lu__assert(!rec->brain);

		rec->brain = self;

		// find empty slot
		lu_size i;
		for(i = 0; i < lu_arr__count(self->recs); i++)
		{
			if (lu_arr__get(self->recs, i) == NULL) break;
		}
		
		rec->id = i;
		lu_arr__set(self->recs, rec->id, rec);

		return rec->id;
	}

	static void lu_brain__rec_detach(Lu_Brain self, Lu_Rec rec)
	{
		lu__assert(self);
		lu__assert(rec->brain);
		lu__assert(self->s);

		lu_arr__set(self->recs, rec->id, NULL);
		
		rec->brain = NULL;
	}

	Lu_Rec lu_brain__get_rec_by_id(Lu_Brain brain, lu_size rec_id)
	{
		lu__user_assert(brain, "Lu_Brain is NULL");
		lu__assert(brain->recs);
		lu__user_assert(rec_id < lu_arr__count(brain->recs), "rec_id is out of range");

		return (Lu_Rec) lu_arr__get(brain->recs, rec_id);
	}

	lu_size lu_brain__recs_size(Lu_Brain self) { return lu_arr__size(self->recs); }

	// For MVP this method will destroy and re-create s_mem and n_mem.
	// In future we might want to preserve n_mem (adding recs on fly).
	Lu_Brain lu_brain__build(Lu_Brain self) 
	{
		lu__user_assert(self, "Lu_Brain is NULL");

		//
		// Destroy if exist
		//

		if (self->s)
		{
			lu_s__destroy(self->s);
			self->s_mem = NULL;
		}

		if (self->n)
		{
			lu_n__destroy(self->n);
			self->n = NULL;
		}

		//
		// Create S
		// 
 
 		// (Lu_Mem mem, Lu_S_Layer_Mem cell_mem, Lu_Arr lu_recs);
		self->s = lu_s__create(self->s_mem, self->config.space, self->recs);
		lu__user_assert(self->s, "Cannot create Lu_S. Not enough memory?");

		//
		// Create N
		//

		struct lu_n_config n_config;
		n_config.names_size = self->config.net.names_size;

		self->n = lu_n__create(self, n_config);
		lu__user_assert(self->n, "Cannot create Lu_N. Not enough memory?");

		return self;
	}

	