/**
	Copyright Â© 2022 Oleh Ihorovych Novosad 
*/

///////////////////////////////////////////////////////////////////////////////
// Brain API

	Lu_Brain lu_brain__create(struct lu_config config)
	{
		Lu_Config p_config = lu_config__validate(&config);
		lu__user_assert(p_config, "Lu_Config validation failed");

		if (p_config->res == NULL)
		{
			p_config->res = lu_res__create_default();
			lu__user_assert(p_config->res, "Something is wrong, cannot create Lu_Res");
		}

		Lu_Brain self 		= (Lu_Brain) lu_mem__alloc(p_config->res->brain_mem, sizeof(struct lu_brain));
		lu__user_assert(self, "Cannot allocate Lu_Brain. Not enough memory?");
		
		self->config 		= *p_config;
		self->recs 			= lu_arr__temp_create(p_config->b_recs_size, false);

		self->s 			= NULL;
		self->n 			= NULL;

		return self;
	}

	void lu_brain__destroy(Lu_Brain self)
	{
		lu__assert(self);
		lu__assert(self->res.brain_mem);

		Lu_Mem brain_mem = self->res.brain_mem;

		lu__user_assert_void(self, "Lu_Brain is NULL");

		if (self->n) 
		{
			lu_n__destroy(self->n);
			self->n = NULL;
		}

		if (self->s) 
		{	
			lu_s__destroy(self->s);
			self->s = NULL;
		}

		Lu_Rec rec;
		if (self->recs)
			for (lu_size i = 0; i < lu_arr__count(self->recs); i++)
			{
				rec = (Lu_Rec) lu_arr__get(self->recs, i);

				if (rec)
					lu_rec__destroy(rec, brain_mem);
			}

		lu_arr__destroy(self->recs);

		lu_res__deinit(&self->res);

		lu_mem__free(brain_mem, (lu_p_byte) self);
	}

	void lu_brain__print_info(Lu_Brain self)
	{
		lu__user_assert_void(self, "Lu_Brain is NULL");
		lu__user_assert_void(self->res.brain_mem, "Lu_Mem is NULL");

		lu__debug("\n\n=========> Brain #%lu Info <=========", self->config.id);
		lu__debug("\nMemory allocated (bytes): %lu", lu_mem__preallocated(self->res.brain_mem));
		lu__debug("\nMemory used (bytes): %lu", lu_mem__used(self->res.brain_mem));

 		if (self->s)
 			lu_s__print_info(self->s);

 		// if (self->n)
 		// 		lu_n__print_info(self->n);
	}

	struct lu_config lu_brain_config_get(Lu_Brain self)
	{
		lu__assert(self);

		return self->config;
	}

	Lu_Brain lu_brain__reconfig(Lu_Brain self, struct lu_config config)
	{
		lu__user_assert(NULL, "Not implemented yet");
	}

	static lu_size lu_brain__rec_attach(Lu_Brain self, Lu_Rec rec)
	{
		lu__assert(self);
		lu__assert(rec);
		lu__assert(self->recs);
		lu__assert(!rec->brain);

		rec->brain = self;

		// find empty slot
		lu_size i;
		for(i = 0; i < lu_arr__count(self->recs); i++)
		{
			if (lu_arr__get(self->recs, i) == NULL) break;
		}
		
		rec->id = i;
		lu_arr__set(self->recs, rec->id, rec);

		return rec->id;
	}

	static void lu_brain__rec_detach(Lu_Brain self, Lu_Rec rec)
	{
		lu__assert(self);
		lu__assert(rec->brain);
		lu__assert(self->s);

		lu_arr__set(self->recs, rec->id, NULL);
		
		rec->brain = NULL;
	}

	Lu_Rec lu_brain__get_rec_by_id(Lu_Brain brain, lu_size rec_id)
	{
		lu__user_assert(brain, "Lu_Brain is NULL");
		lu__assert(brain->recs);
		lu__user_assert(rec_id < lu_arr__count(brain->recs), "rec_id is out of range");

		return (Lu_Rec) lu_arr__get(brain->recs, rec_id);
	}

	lu_size lu_brain__recs_size(Lu_Brain self) { return lu_arr__size(self->recs); }

	// For MVP this method will destroy and re-create s_mem and n_mem.
	// In future we might want to preserve n_mem (adding recs on fly).
	Lu_Brain lu_brain__build(Lu_Brain self) 
	{
		lu__user_assert(self, "Lu_Brain is NULL");

		//
		// Destroy if exist
		//

		if (self->s)
		{
			lu_s__destroy(self->s);
			self->s = NULL;
		}

		if (self->n)
		{
			lu_n__destroy(self->n);
			self->n = NULL;
		}

		//
		// Create S
		// 
 
 		// (Lu_Mem mem, Lu_S_Layer_Mem cell_mem, Lu_Arr lu_recs);
		self->s = lu_s__create_intersected_squares_cortex(
			&self->res,
			&self->config, 
			self->recs
		);
		lu__user_assert(self->s, "Cannot create Lu_S. Not enough memory?");

		//
		// Create N
		//

		struct lu_n_config n_config;
		n_config.names_size = self->config.net.names_size;

		self->n = lu_n__create(self->res.n_mem, n_config);
		lu__user_assert(self->n, "Cannot create Lu_N. Not enough memory?");

		return self;
	}

	