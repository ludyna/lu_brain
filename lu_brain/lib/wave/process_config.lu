/**
	Copyright Â© 2022 Oleh Ihorovych Novosad 
*/

///////////////////////////////////////////////////////////////////////////////
// Lu_Process_Config 

    static Lu_Process_Config lu_wave_config__init(Lu_Process_Config self)
    {
        self->flags                 = 0;
        self->p_potency             = 1.0,    
        self->v_potency             = 1.0,
        self->min_fire_potency      = 0.9;
        self->block_layers_size     = 50;

        return self;
    }   

///////////////////////////////////////////////////////////////////////////////
// Lu_Process_Config predefined
    
    struct lu_process_config lu_g_wc_predefined[LU_PROCESS__END] = { 
    	// LU_PROCESS__SAVE_DEFAULT
    	{
            .flags                        = 0,
    		.p_potency                    = 1.0,  	
            .v_potency                    = 1.0,
            .min_potency                  = 0.05,
    		.min_fire_potency             = 0.9,  	// potribna povna kopiya
            .block_layers_size            = 50
    	},
    	// LU_PROCESS__MATCH_DIFF_ONLY
    	{

    	},
    	// LU_PROCESS__MATCH_VALUE_ONLY
    	{

    	}
    };

  	struct lu_process_config lu_process_config__get_by_id(lu_size id)
  	{
  		lu__assert(id < LU_PROCESS__END);
  		return lu_g_wc_predefined[id];
  	}

///////////////////////////////////////////////////////////////////////////////
//  Lu_Process_Config

  	Lu_Process_Config lu_process_config__validate(Lu_Process_Config self) 
  	{
  		lu__user_assert(self->p_potency >= 0 && self->p_potency <= 1, "p_potency should be in [0, 1]");
        lu__user_assert(self->v_potency >= 0 && self->v_potency <= 1, "p_potency should be in [0, 1]");
  		lu__user_assert(self->min_fire_potency > 0 && self->min_fire_potency < 1, "min_fire_potency should be in (0, 1)");

  		return self;
  	}