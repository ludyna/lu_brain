/**
	Copyright Â© 2022 Oleh Ihorovych Novosad 
*/

	static void lu_save_wave__destroy_virtual(Lu_Wave wave);
	static void lu_match_wave__destroy_virtual(Lu_Wave wave);
	static void lu_restore_wave__destroy_virtual(Lu_Wave wave);

///////////////////////////////////////////////////////////////////////////////
// Init 
	static inline Lu_Wave lu_wave__init(
		Lu_Wave self, 
		enum lu_wave_type type, 
		Lu_Brain brain
	)
	{
		lu__assert(self);
		lu__assert(brain);

		Lu_Config b_config = &brain->config;
		lu__assert(b_config);

		self->wave_id = 0;
		self->type = type;
	
		lu__assert(b_config->w_mem);
		self->mem = b_config->w_mem;

		self->brain = brain;

		// Setting last proccess config to default
		struct lu_process_config config = lu_process_config__get_by_id(LU_PROCESS__SAVE_DEFAULT);
		Lu_Process_Config p_config = lu_process_config__validate(&config);
		lu__assert(p_config);

		self->config = config;

		self->destroy = NULL;
		self->block_begin = NULL;
		self->block_end = NULL;
		self->push = NULL;
		self->reset = NULL;
		self->step = NULL;
		self->process = NULL;

		return self;
	}
 
///////////////////////////////////////////////////////////////////////////////
// Properties

	struct lu_process_config lu_wave__get_process_config(Lu_Wave self)
	{
		lu__debug_assert(self);
		return self->config;
	}

	lu_size lu_wave__get_id(Lu_Wave self)
	{
		return self->wave_id;
	}

	lu_size lu_wave__get_ix(Lu_Wave self)
	{
		return self->wave_ix;
	}

	enum lu_wave_type lu_wave__get_type(Lu_Wave self)
	{
		return self->type;
	}

	// lu_size lu_wave_block_count(Lu_Wave self)
	// {
	// 	lu__assert(self);
	// }

	// Lu_Data lu_wave_last_data(Lu_Wave self, Lu_Rec rec)
	// {
	// 	lu__user_assert(self, "Lu_Wave is NULL");
	// 	lu__user_assert(rec, "Lu_Rec is NULL");
	// }

///////////////////////////////////////////////////////////////////////////////
// Block Begin

	void lu_wave__block_begin(Lu_Wave self)
	{
		lu__user_assert_void(self, "Lu_Wave is NULL");

		if (self->block_begin)
			self->block_begin(self);
		else lu__user_assert_void(false, "Method is not supported by this wave implementation");
	}

	static void lu_save_wave__block_begin_virtual(Lu_Wave self)
	{
		lu__assert(self);
		lu__assert(lu_wave__is_save(self));

		Lu_Save_Wave save_wave = (Lu_Save_Wave) self;
		lu_data_seq__block_begin(save_wave->seq);
	} 

	static void lu_match_wave__block_begin_virtual(Lu_Wave self)
	{
		lu__assert(self);
		lu__assert(lu_wave__is_match(self));

		Lu_Match_Wave match_wave = (Lu_Match_Wave) self;
		lu_data_seq__block_begin(match_wave->seq);
	} 

	static void lu_restore_wave__block_begin_virtual(Lu_Wave self)
	{

	} 

///////////////////////////////////////////////////////////////////////////////
// Block End

	void lu_wave__block_end(Lu_Wave self)
	{
		lu__user_assert_void(self, "Lu_Wave is NULL");

		if (self->block_end)
			self->block_end(self);
		else lu__user_assert_void(false, "Method is not supported by this wave implementation");
	}

	static void lu_save_wave__block_end_virtual(Lu_Wave self)
	{
		lu__assert(self);
		lu__assert(lu_wave__is_save(self));

		Lu_Save_Wave save_wave = (Lu_Save_Wave) self;
		lu_data_seq__block_end(save_wave->seq);
	} 

	static void lu_match_wave__block_end_virtual(Lu_Wave self)
	{
		lu__assert(self);
		lu__assert(lu_wave__is_save(self));

		Lu_Match_Wave match_wave = (Lu_Match_Wave) self;
		lu_data_seq__block_end(match_wave->seq);
	} 

	static void lu_restore_wave__block_end_virtual(Lu_Wave self)
	{

	}  


///////////////////////////////////////////////////////////////////////////////
// Process block

	static void lu_save_wave__process_block(Lu_Save_Wave self, Lu_Data_Block block, Lu_Process_Config config)
	{
		lu__assert(self);
		lu__assert(block);

		Lu_Wave wave = (Lu_Wave) self;
		Lu_Brain brain = wave->brain;
		lu__assert(brain);

		Lu_S s = brain->s;
		lu__assert(s);

		// lu_size rec_id;
		// lu_size size = lu_data_block__get_size(block);
		// Lu_Data data;
		// for (rec_id = 0; rec_id < size; rec_id++)
		// {
		// 	data = lu_data_block__get_data(block, rec_id);
		// 	lu__assert(data);

		// 	if (lu_data__is_empty(data)) continue;
			
		// 	lu_data__print(data);

		// lu_s__save_rec_data(s, wave, rec_id, data, config);
		// }

		Lu_Data data;
		lu_size rec_id = 0; // NOTE: fixed temporarily

		data = lu_data_block__get_data(block, rec_id);
		lu_size block_ix = data->block_ix;

		//
		// Rec
		// 

		Lu_S_Area area = lu_s__get_area_by_tag(s, LU_AREA_TAG__REC/*, rec_id */);
		lu__assert(area);
		lu__assert(area->tag == LU_AREA_TAG__REC);
		 
		Lu_W_Table curr_w_table = lu_s_area__save_rec(area, self, rec_id, data, config);

		if (curr_w_table == NULL) return;

		//
		// Frame
		//

		area = lu_s__get_area_by_tag(s, LU_AREA_TAG__FRAME);
		lu__assert(area);
		lu__assert(area->tag == LU_AREA_TAG__FRAME);

		curr_w_table = lu_s_area__save_frame(area, self, block_ix, curr_w_table, config);

		if (curr_w_table == NULL) return;

		//
		// Seq
		//

		area = lu_s__get_area_by_tag(s, LU_AREA_TAG__SEQ);
		lu__assert(area);
		lu__assert(area->tag == LU_AREA_TAG__SEQ);

		curr_w_table = lu_s_area__save_seq(area, self, block_ix, curr_w_table, config);
	}

	static void lu_match_wave__process_block(Lu_Match_Wave self, Lu_Data_Block block, Lu_Process_Config config)
	{
		lu__assert(self);
		lu__assert(block);

		Lu_Wave wave = (Lu_Wave) self;
		Lu_Brain brain = wave->brain;
		lu__assert(brain);

		Lu_S s = brain->s;
		lu__assert(s);

		Lu_Data data;
		lu_size rec_id = 0; // NOTE: fixed temporarily

		data = lu_data_block__get_data(block, rec_id);

		Lu_S_Area area = lu_s__get_area_by_tag(s, LU_AREA_TAG__REC/*, rec_id */);
		lu__assert(area);
		lu__assert(area->tag == LU_AREA_TAG__REC);
		 
		lu_s_area__match_rec(area, self, rec_id, data, config, &self->processor);

		lu__debug("\n LIM_NEXT_COUNT = %ld\n", lu_lim_list__count(self->processor.next_list));
	}

///////////////////////////////////////////////////////////////////////////////
// Push

	void lu_wave__push(Lu_Wave self, Lu_Rec rec, lu_value* data)
	{
		lu__user_assert_void(self, "Lu_Wave is NULL");
		lu__user_assert_void(rec, "Lu_Rec is NULL");
		lu__user_assert_void(data, "data is NULL");

		if (self->push)
			self->push(self, rec, data);
		else lu__user_assert_void(false, "Method is not supported by this wave implementation");
	} 

	void lu_wave__push_with_shift(Lu_Wave self, Lu_Rec rec, lu_value* data, lu_size x_shift, lu_size y_shift)
	{
		lu__user_assert_void(self, "Lu_Wave is NULL");
		lu__user_assert_void(rec, "Lu_Rec is NULL");
		lu__user_assert_void(data, "data is NULL");
		lu__user_assert_void(
			x_shift > 0 || y_shift > 0, 
			"x_shift should be greater than 0 or y_shift should be greater than 0"
		);

		struct lu_data data_1;
		lu_data__set(
			&data_1, 
			LU_WAVE_IX__NOT_SET, 
			LU_BLOCK_IX__NOT_SET, 
			LU_REC_ID__NOT_SET, 
			rec->width,
			rec->height,
			rec->depth,
			data
		);

		Lu_Data data_2 = lu_data__create_via_shift(self->mem, &data_1, x_shift, y_shift);
		lu__create_assert(data_2);

		if (self->push)
		{
			self->push(self, rec, data);

			self->push(self, rec, data_2->values);
		}

		lu_data__destroy(data_2, self->mem);
	}

	static void lu_save_wave__push_virtual(Lu_Wave self, Lu_Rec rec, lu_value *data)
	{
		lu__assert(self);
		lu__assert(lu_wave__is_save(self));

		Lu_Save_Wave save_wave = (Lu_Save_Wave) self;
		lu_data_seq__push(save_wave->seq, rec, data);
	}

	static void lu_match_wave__push_virtual(Lu_Wave self, Lu_Rec rec, lu_value *data)
	{
		lu__assert(self);
		lu__assert(lu_wave__is_match(self));

		Lu_Match_Wave match_wave = (Lu_Match_Wave) self;
		lu_data_seq__push(match_wave->seq, rec, data);
	}

///////////////////////////////////////////////////////////////////////////////
// Step

	void lu_wave__step(Lu_Wave self, struct lu_process_config config)
	{
		lu__user_assert_void(self, "Lu_Wave is NULL");

		Lu_Process_Config p_config = lu_process_config__validate(&config);
		lu__user_assert_void(p_config, "Lu_Process_Config is invalid");

		self->config = config;

		if (self->step)
			self->step(self, &self->config);
		else lu__user_assert_void(false, "Method is not supported by this wave implementation");
	}


	static void lu_save_wave__step_virtual(Lu_Wave self, Lu_Process_Config config)
	{
		lu__assert(self);
		lu__assert(lu_wave__is_save(self));
		lu__assert(config);

		Lu_Save_Wave save_wave = (Lu_Save_Wave) self;

		Lu_Data_Block block = lu_data_seq__next_block_get(save_wave->seq);
		if (!block) return; // nothing to process

		lu_save_wave__process_block(save_wave, block, config);
	}

	static void lu_match_wave__step_virtual(Lu_Wave self, Lu_Process_Config config)
	{
		lu__assert(self);
		lu__assert(lu_wave__is_match(self));
		lu__assert(config);

		Lu_Match_Wave match_wave = (Lu_Match_Wave) self;

		Lu_Data_Block block = lu_data_seq__next_block_get(match_wave->seq);
		if (!block) return; // nothing to process

		lu_match_wave__process_block(match_wave, block, config);
	}

	static void lu_restore_wave__step_virtual(Lu_Wave self, Lu_Process_Config config)
	{
		lu__assert(self);
		lu__assert(lu_wave__is_restore(self));
	}

///////////////////////////////////////////////////////////////////////////////
// Process

	//
	// Wave
	//

	void lu_wave__process(Lu_Wave self, struct lu_process_config config)
	{
		lu__user_assert_void(self, "Lu_Wave is NULL");

		Lu_Process_Config p_config = lu_process_config__validate(&config);
		lu__user_assert_void(p_config, "Lu_Process_Config is invalid");

		self->config = config; // save last process config 

		if (self->process)
			self->process(self, &self->config);
		else lu__user_assert_void(false, "Method is not supported by this wave implementation");
	}

	//
	// Save
	//

	static void lu_save_wave__process_virtual(Lu_Wave self, Lu_Process_Config config)
	{
		lu__assert(self);
		lu__assert(lu_wave__is_save(self));

		Lu_Save_Wave save_wave = (Lu_Save_Wave) self;

		Lu_Data_Block block = NULL;

		while((block = lu_data_seq__next_block_get(save_wave->seq)))
		{
			lu__debug("\n BEFORE PROCESS BLOCK: wave_id=%ld, block_ix=%ld", save_wave->seq->wave_id, block->block_ix);
			lu_save_wave__process_block(save_wave, block, config);
		}
	}

	//
	// Find
	//

	static void lu_match_wave__process_virtual(Lu_Wave self, Lu_Process_Config config)
	{
		lu__assert(self);
		lu__assert(lu_wave__is_match(self));

		Lu_Match_Wave match_wave = (Lu_Match_Wave) self;

		Lu_Data_Block block = NULL;

		while((block = lu_data_seq__next_block_get(match_wave->seq)))
			lu_match_wave__process_block(match_wave, block, config);
	}

	//
	// Restore
	//

	static void lu_restore_wave__process_virtual(Lu_Wave self, Lu_Process_Config config)
	{
		lu__assert(self);
		lu__assert(lu_wave__is_restore(self));
	}

///////////////////////////////////////////////////////////////////////////////
// Reset

	void lu_wave__reset(Lu_Wave self)
	{
		lu__user_assert_void(self, "Lu_Wave is NULL");

		if (self->reset)
			self->reset(self);
		else lu__user_assert_void(false, "Method is not supported by this wave implementation");
	}

	void lu_save_wave__reset(Lu_Wave self)
	{
		lu__assert(self);
		Lu_Save_Wave save_wave = (Lu_Save_Wave) self;

		lu_data_seq__reset(save_wave->seq);  	
	}

///////////////////////////////////////////////////////////////////////////////
// Create

	Lu_Wave lu_wave__create_save_wave(Lu_Brain brain) 
	{
		lu__user_assert(brain, "Lu_Brain is NULL");

		Lu_Mem w_mem = brain->config.w_mem;
		lu__user_assert(w_mem, "w_mem is NULL");

		Lu_Save_Wave self = (Lu_Save_Wave) lu_mem__alloc(w_mem, sizeof(struct lu_save_wave));

		lu_wave__init(
			&self->super, 
			LU_WAVE__SAVE, 
			brain
		); 

		self->super.destroy = lu_save_wave__destroy_virtual;
		
		self->super.block_begin = lu_save_wave__block_begin_virtual;
		self->super.block_end = lu_save_wave__block_end_virtual;

		self->super.push = lu_save_wave__push_virtual;
		self->super.reset = lu_save_wave__reset;

		self->super.step = lu_save_wave__step_virtual;
		self->super.process = lu_save_wave__process_virtual;

		bool success = lu_w_manager__register_wave(brain->w_manager, (Lu_Wave) self);
		lu__user_assert(success, "Cannot register Lu_Wave. Not enough memory? Check Lu_Config w_save_waves_size.");

		self->seq = lu_data_seq__create(w_mem, self->super.wave_ix, lu_brain__recs_size(brain)); 
		lu__assert(self->seq);

		return (Lu_Wave) self;
	}
	
	//
	// Match is more generalized "find".
	// 
	Lu_Wave lu_wave__create_match_wave(Lu_Brain brain)
	{
		lu__user_assert(brain, "Lu_Brain is NULL");

		Lu_Mem w_mem = brain->config.w_mem;
		lu__user_assert(w_mem, "w_mem is NULL");

		Lu_Match_Wave self = (Lu_Match_Wave) lu_mem__alloc(w_mem, sizeof(struct lu_match_wave));

		lu_wave__init(
			&self->super,
			LU_WAVE__MATCH,
			brain
		);

		lu__assert(lu_wave__is_match((Lu_Wave) self));
		lu__assert(lu_wave__get_type((Lu_Wave) self) == LU_WAVE__MATCH);

		self->super.destroy = lu_match_wave__destroy_virtual;
		
		self->super.block_begin = lu_match_wave__block_begin_virtual;
		self->super.block_end = lu_match_wave__block_end_virtual;

		self->super.push = lu_match_wave__push_virtual;

		self->super.step = lu_match_wave__step_virtual;
		self->super.process = lu_match_wave__process_virtual;

		bool success = lu_w_manager__register_wave(brain->w_manager, (Lu_Wave) self);
		lu__user_assert(success, "Cannot register Lu_Wave. Not enough memory? Check Lu_Config w_save_waves_size.");

		self->seq = lu_data_seq__create(w_mem, self->super.wave_ix, lu_brain__recs_size(brain)); 
		lu__assert(self->seq);

		lu_w_match_cell_mem__init(&self->match_cell_mem, w_mem, brain->config.w_match_cells_size_per_wave);

		lu_w_processor__init(&self->processor, brain->s, &brain->config, &self->match_cell_mem, &brain->la_column);

		return (Lu_Wave) self;
	}

	Lu_Wave lu_wave__create_restore_wave(Lu_Brain brain)
	{
		return NULL;
	}

///////////////////////////////////////////////////////////////////////////////
// Destroy

	void lu_wave__destroy(Lu_Wave self)
	{
		lu__user_assert_void(self, "Lu_Wave is NULL");
		lu__user_assert_void(self->brain, "Something went wrong. Lu_Wave is not linked to any Lu_Brain");
		lu__assert(self->brain->w_manager);

		lu_w_manager__unregister_wave(self->brain->w_manager, self);

		self->destroy(self);

		lu_mem__free(self->mem, (lu_p_byte) self);
	} 

	//
	// Save
	//

	static void lu_save_wave__destroy_virtual(Lu_Wave wave)
	{
		lu__assert(wave);
		lu__assert(lu_wave__is_save(wave));

		Lu_Save_Wave self = (Lu_Save_Wave) wave;

		lu_data_seq__destroy(self->seq);
	}

	//
	// Find
	//

	static void lu_match_wave__destroy_virtual(Lu_Wave wave)
	{
		lu__assert(wave);
		lu__assert(lu_wave__is_match(wave));

		Lu_Match_Wave self = (Lu_Match_Wave) wave;

		lu_w_processor__deinit(&self->processor);

		lu_w_match_cell_mem__deinit(&self->match_cell_mem);

		lu_data_seq__destroy(self->seq);
	}

	//
	// Restore
	//

	static void lu_restore_wave__destroy_virtual(Lu_Wave wave)
	{
		// lu__assert(wave);
		// Lu_Restore_Wave self = (Lu_Restore_Wave) wave;

		//lu_list__destroy(self->seq);
	}


///////////////////////////////////////////////////////////////////////////////
// 

	Lu_La_Cell lu_wave__link_to_label(Lu_Wave self, lu_size area_ix, lu_size layer_ix, lu_size x, lu_size y, lu_size label)
	{
		lu__user_assert(self, "Lu_Wave is NULL");
		lu__user_assert(self->brain, "Lu_Wave brain is NULL");
		lu__user_assert(self->brain->s, "Lu_Wave brain structure is NULL");

		Lu_W_Cell w_cell = lu_s__get_w_cell(self->brain->s, self->wave_id, area_ix, layer_ix, x, y);

		if (w_cell == NULL) return NULL;

		if (w_cell->n_cell == NULL) return NULL;

		return lu_la_column__save_label(&self->brain->la_column, w_cell->n_cell, label);
	}

	Lu_Label* lu_wave__get_result_labels(Lu_Wave self)
	{
		lu__assert(self);
		lu__assert(lu_wave__get_type(self) == LU_WAVE__MATCH);

		Lu_Match_Wave match_wave = (Lu_Match_Wave) self;

		return match_wave->processor.sorted_results;
	}