/**
	Copyright Â© 2022 Oleh Ihorovych Novosad 
*/ 

///////////////////////////////////////////////////////////////////////////////
// 

	static Lu_N_Table_Comp lu_n_table_comp__create(
		Lu_Config config, 
		Lu_Comp_Calc comp_calc, 
		lu_size width, 
		lu_size height, 
		lu_size depth,
		lu_size layer_ix
	)
	{
		lu__assert(config);
		lu__assert(comp_calc);
		lu__assert(width > 0);
		lu__assert(height > 0);
		lu__assert(depth > 0);
		lu__assert(comp_calc->cells_size == depth);

		Lu_N_Table_Comp self = (Lu_N_Table_Comp) lu_mem__alloc(config->n_mem, sizeof(struct lu_n_table_comp));
		lu__assert(self);

		self->mem = config->n_mem;
		self->w = width;
		self->h = height;
		self->d = depth;
		self->wh = self->w * self->h;
		self->size = self->wh * self->d;

		self->cells = (struct lu_n_cell_vp*) lu_mem__alloc(
			self->mem, 
			sizeof(struct lu_n_cell_vp) * self->size
		);

		lu_size z;
		lu_size x;
		lu_size y;
		Lu_N_Cell_VP cell;

		lu_size z_shift;
		lu_size zy_shift;

		union lu_n_addr addr;
		lu_size column_ix;
		struct lu_n_pos pos;

		for (z = 0; z < depth; z++)
		{
			z_shift = z * self->wh;
			for (y = 0; y < height; y++)
			{
				zy_shift = z_shift + y * width;
				for (x = 0; x < width; x++)
				{
					cell = &self->cells[zy_shift + x]; 

					pos.x = x;
					pos.y = y;

					column_ix = lu_n_pos__to_column_ix(&pos, self->w);

					lu_n_addr__init(&addr, z, column_ix, layer_ix);

					lu_n_cell_vp__init(cell, comp_calc->steps[z], x, y, z, addr);
				} 
			}
		}

		return self;
	}

	static void lu_n_table_comp__destroy(Lu_N_Table_Comp self)
	{
		lu__assert(self);
		lu__assert(self->mem);

		lu_mem__free(self->mem, (lu_p_byte) self->cells);
		lu_mem__free(self->mem, (lu_p_byte) self);
	}


///////////////////////////////////////////////////////////////////////////////
// 
