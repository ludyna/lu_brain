/**
	Copyright Â© 2022 Oleh Ihorovych Novosad 
*/

///////////////////////////////////////////////////////////////////////////////
// 

	static Lu_N_Col lu_n_col__init(
		Lu_N_Col self, 
		Lu_N_Table n_table,
		Lu_Mem mem, 
		lu_size cells_size, 
		lu_size area_ix,
		lu_size layer_ix, 
		lu_size column_ix,
		Lu_Config config,
		lu_size x,
		lu_size y
	)
	{
		lu__assert(self);
		lu__assert(n_table);
		lu__assert(mem);
		lu__assert(cells_size > 1);

		self->n_table = n_table;
		self->mem = mem;
		self->column_ix = column_ix;
		self->x = x;
		self->y = y;
		self->cells_size = cells_size;


		self->cells = (struct lu_n_cell*) lu_mem__alloc(mem, sizeof(struct lu_n_cell) * self->cells_size);
		lu__alloc_assert(self->cells);

		self->w_match_cells_size = config->w_match_waves_size;

		for (lu_size i = 0; i < self->cells_size; i++)
		{
			lu_n_cell__init(&self->cells[i], i, column_ix, layer_ix, area_ix, mem, self->w_match_cells_size);
		}

		lu_n_link_mem__init(&self->link_mem, mem, config->n_link_mem_size);

		return self;
	}

	static void lu_n_col__deinit(Lu_N_Col self)
	{
		lu__assert(self);
		lu__assert(self->mem);

		lu_n_link_mem__deinit(&self->link_mem);

		// for (lu_size i = 0; i < self->cells_size; i++)
		// {
		// 	lu_n_cell__deinit(&self->cells[i], self->mem);
		// }

		lu_mem__free(self->mem, (lu_p_byte) self->cells);
		
		self->cells = NULL;
		self->cells_size = 0;
		self->cells_count = 0;
		self->mem = NULL;
	}


///////////////////////////////////////////////////////////////////////////////
// 

	static void lu_n_col__realloc(Lu_N_Col self)
	{
		lu__assert(self);
		lu__assert(self->mem);

		lu_size old_cells_size = self->cells_size;

		self->cells_size = old_cells_size * 2;

		self->cells = (struct lu_n_cell*) lu_mem__realloc(
			self->mem, 
			(lu_p_byte) self->cells, 
			sizeof(struct lu_n_cell) * self->cells_size
		);
		lu__alloc_assert(self->cells);

		//
		// Init new cells
		//

		lu_size i;
		Lu_N_Cell n_cell;
		Lu_N_Cell null_n_cell = lu_n_col__get_null_cell(self);
		for (i = old_cells_size; i < self->cells_size; i++)
		{
			n_cell = &self->cells[i];

			lu_n_cell__init(
				n_cell, 
				i, 
				self->column_ix, 
				null_n_cell->addr.layer_ix, 
				null_n_cell->addr.area_ix, 
				self->mem, 
				self->w_match_cells_size
			);
		}
	}

	static Lu_N_Cell lu_n_col__create_or_find_n_cell_by_vp_children(
		Lu_N_Col self, 
		Lu_W_Cell_P* children, 
		lu_size children_count,
		Lu_Block_Id block_id,
		lu_size wave_ix
	)
	{
		lu__debug_assert(self);
		lu__debug_assert(children);
		lu__debug_assert(children_count > 0);


		Lu_W_Save_Cell max_save_cell = NULL;
		Lu_N_Cell max_n_cell = NULL;

		lu_size i;
		for (i = 0; i < children_count; i++)
		{
			lu_w_cell_p__send_sig_to_parents_and_return_cell_with_max_sig(
				children[i], 
				block_id,
				wave_ix,
				&max_save_cell,
				&max_n_cell
			);
		}

		if (max_save_cell == NULL || !lu_w_save_cell__is_sig_over_breakpoint(max_save_cell, max_n_cell, .76))
		{
			// create new neuron
			max_n_cell = lu_n_col__alloc_n_cell(self);

			if (max_n_cell == NULL)
			{
				lu_n_col__realloc(self);
				max_n_cell = lu_n_col__alloc_n_cell(self);
				lu__assert(max_n_cell);
			}

			lu_n_cell__vp_save(max_n_cell, children, children_count, &self->link_mem);
		}

		return max_n_cell;
	}

	static Lu_N_Cell lu_n_col__create_or_find_n_cell_by_children(
		Lu_N_Col self, 
		Lu_W_Cell* children, 
		lu_size children_count,
		Lu_Block_Id block_id,
		lu_size wave_ix
	)
	{
		lu__debug_assert(self);
		lu__debug_assert(children);
		lu__debug_assert(children_count > 0);

		Lu_W_Save_Cell max_save_cell = NULL;
		Lu_N_Cell max_n_cell = NULL;

		lu_size i;
		for (i = 0; i < children_count; i++)
		{
			// prev_w_save_cell = lu_n_cell__get_w_save_cell(n_cell, wave_ix);
			// lu_w_save_cell__calc_fire_sig(prev_w_save_cell, n_cell->default_sig)

			lu_w_cell__send_sig_to_parents_and_return_cell_with_max_sig(
				children[i], 
				block_id,
				wave_ix,
				&max_save_cell,
				&max_n_cell
			);
		}

		if (max_save_cell == NULL || !lu_w_save_cell__is_sig_over_breakpoint(max_save_cell, max_n_cell, .73))
		{
			// create new neuron
			max_n_cell = lu_n_col__alloc_n_cell(self);

			if (max_n_cell == NULL)
			{
				lu_n_col__realloc(self);
				max_n_cell = lu_n_col__alloc_n_cell(self);
				lu__assert(max_n_cell);
			}

			lu_n_cell__save(max_n_cell, children, children_count, &self->link_mem);
		}

		return max_n_cell;
	}