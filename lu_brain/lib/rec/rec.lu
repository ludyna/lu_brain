 /**
	Copyright Â© 2022 Oleh Ihorovych Novosad 
*/
 
///////////////////////////////////////////////////////////////////////////////
// Init, create and destroy

	// 
	// It is actually lu_brain_rec_create_and_add, but lu_brain__rec_add for shortness.
	//
	Lu_Rec lu_brain__rec_add(Lu_Brain brain, lu_size width, lu_size height, lu_size depth, struct lu_rec_config config)
	{
		lu__user_assert(brain, "Lu_Brain is NULL");
		lu__user_assert(brain->config.b_mem, "b_mem is NULL");
		lu__user_assert(width, "widht should be greater than 0");
		lu__user_assert(height, "widht should be greater than 0");
		lu__user_assert(depth, "widht should be greater than 0");
	 
	 	Lu_Rec_Config p_config 	= lu_rec_config__validate(&config);
	 	lu__user_assert(p_config, "Lu_Rec_Config validation failed");

		Lu_Rec self = (Lu_Rec) lu_mem__alloc(brain->config.b_mem, sizeof(struct lu_rec));
		lu__user_assert(self, "Cannot allocate lu_rec");

		// Initialize
		self->config = *p_config;

		self->width = width;
		self->height = height;
		self->depth = depth;

		//
		// View
		//

		self->src_start_x = 0;
		self->src_start_y = 0;

		self->dest_start_x = 0;
		self->dest_start_y = 0;

		lu_brain__rec_attach(brain, self);

		return self;
	}

	void lu_brain__rec_remove(Lu_Rec self)
	{
		if (self->brain)
			lu_brain__rec_detach(self->brain, self);
	}


	static void lu_rec__destroy(Lu_Rec self, Lu_Mem mem)
	{
		lu__assert(self);
		lu_mem__free(mem, (lu_p_byte) self);
	}

	lu_size lu_rec__get_id(Lu_Rec self)
	{
		lu__assert(self);
		return self->id;
	}

///////////////////////////////////////////////////////////////////////////////
// 

	void lu_rec__set_dest_pos(Lu_Rec self, lu_long dest_x, lu_long dest_y)
	{
		lu__user_assert_void(self, "Rec is NULL");
	}

	void lu_rec__set_src_pos(Lu_Rec self, lu_long src_x, lu_long src_y)
	{
		lu__user_assert_void(self, "Rec is NULL");
	}
