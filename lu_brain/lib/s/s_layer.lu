/**
	Copyright Â© 2022 Oleh Ihorovych Novosad 
*/

///////////////////////////////////////////////////////////////////////////////
// 

	static Lu_S_Layer lu_s_layer__init(
		Lu_S_Layer self, 
		Lu_Config config, 
		enum lu_s_layer_type type,
		lu_size layer_ix, 
		lu_size area_ix,
		lu_size children_count,
		void (*destroy)(Lu_S_Layer_Base),
		lu_size n_w,
		lu_size n_h,
		lu_size n_h_max,
		enum lu_area_tag tag
	)
	{
		lu__assert(self);
		lu__assert(config);
		lu__assert(n_w > 0);
		lu__assert(n_h > 0);

		if (children_count == 0)
		{
			lu_s_layer_base__init(
				&self->super, 
				NULL, 
				config, 
				type, 
				layer_ix,
				area_ix, 
				destroy,
				tag
			); 
		}
		else
		{
			lu_s_layer_base__init_with_arr_c_slot(
				&self->super, 
				NULL, 
				children_count, 
				config, 
				type, 
				layer_ix, 
				area_ix,
				destroy,
				tag
			);
		}

		self->n_table = lu_n_table__create(config->n_mem, n_w, n_h, n_h_max, config, layer_ix, area_ix);
		lu__alloc_assert(self->n_table);

		self->w_save_tables = lu_arr__create(config->w_mem, config->w_save_waves_size, false);
		lu__alloc_assert(self->w_save_tables);

		Lu_W_Table w_table;
		for (lu_size i = 0; i < lu_arr__size(self->w_save_tables); i++)
		{
			w_table = lu_w_table__create(self, config, n_w, n_h, n_h_max);
			lu__alloc_assert(w_table);
			
			lu_arr__set(self->w_save_tables, i, (lu_p_void) w_table);
		}

		return self;
	}

	static void lu_s_layer__deinit(Lu_S_Layer self)
	{
		lu__assert(self);

		Lu_W_Table w_table;
		for (lu_size i = 0; i < lu_arr__count(self->w_save_tables); i++)
		{
			w_table = (Lu_W_Table) lu_arr__get(self->w_save_tables, i);
			lu_w_table__destroy(w_table);
		}

		if (self->n_table)
			lu_n_table__destroy(self->n_table);

		lu_arr__destroy(self->w_save_tables);

		lu_s_layer_base__deinit(&self->super);
	}


	static Lu_S_Layer lu_s_layer__create(
		Lu_Config config, 
		lu_size layer_ix, 
		lu_size area_ix,
		lu_size children_count,
		lu_size n_w,
		lu_size n_h,
		lu_size n_h_max,
		enum lu_area_tag tag
	)
	{
		lu__assert(config);
		lu__assert(config->s_mem);

		Lu_S_Layer self = (Lu_S_Layer) lu_mem__alloc(config->s_mem, sizeof(struct lu_s_layer));
		lu__alloc_assert(self);

		lu_s_layer__init(
			self, 
			config, 
			LU_S_LAYER__LAYER, 
			layer_ix, 
			area_ix,
			children_count, 
			lu_s_layer__destroy, 
			n_w, 
			n_h,
			n_h_max,
			tag
		);

		return self;
	}

	static void lu_s_layer__destroy(Lu_S_Layer_Base self)
	{
		lu__assert(self);
		lu__assert(self->s_mem);

		enum lu_s_layer_type type = lu_s_layer_base__get_type(self);

		lu__assert(type == LU_S_LAYER__LAYER);

		lu_s_layer__deinit((Lu_S_Layer) self);

		lu_mem__free(self->s_mem, (lu_p_byte) self);
	}

///////////////////////////////////////////////////////////////////////////////
// 

	static Lu_W_Table lu_s_layer__save(
		Lu_S_Layer self, 
		lu_size wave_id, 
		lu_size block_id, 
		Lu_W_Table prev_w_table, 
		Lu_Process_Config config
	)
	{
		lu__assert(self);
		lu__assert(prev_w_table);

		lu__assert(prev_w_table->wave_id == wave_id);
		lu__assert(prev_w_table->block_id == block_id);

		lu_size x;
		lu_size y;

		Lu_W_Table curr_w_table = lu_s_layer__get_w_table(self, wave_id);
		lu__assert(curr_w_table);

		curr_w_table->wave_id = wave_id;
		curr_w_table->block_id = block_id;

		Lu_N_Table curr_n_table = self->n_table;
		lu__assert(curr_n_table);

		lu__assert(curr_n_table->w == curr_w_table->w);
		lu__assert(curr_n_table->h == curr_w_table->h);

		lu_size cells_saved_count = 0;

		Lu_W_Cell curr_w_cell;

		curr_w_table->any_fired = false;

		Lu_W_Cell children[LU_N_CELL__CHILDREN_MAX];
		children[LU_N_CELL__CHILDREN_MAX - 1] = NULL;
		
		lu_size non_null_count = 0;

		Lu_N_Column n_column;
		Lu_N_Cell n_cell;

		lu_size i;

		for (y = 0; y < curr_w_table->h; y++)
		{
			for (x = 0; x < curr_w_table->w; x++)
			{
				curr_w_cell = lu_w_table__get_w_cell(curr_w_table, x, y);
				lu__debug_assert(curr_w_cell);

				// We reset so data from previous waves don't interfere
				lu_w_cell__reset(curr_w_cell);

				for (i = 0; i < LU_N_CELL__CHILDREN_MAX; i++)
				{
					children[i] = NULL;
				}

				lu_w_table__collect_children(prev_w_table, x, y, children, &non_null_count);

				lu__debug_assert(non_null_count <= prev_w_table->normal_children_size);

				if (non_null_count)
				{
					n_column = lu_n_table__get_column(curr_n_table, x, y);
					lu__assert(n_column);

					n_cell = lu_n_column__save_with_children(
						n_column, 
						children, 
						prev_w_table->normal_children_size, 
						non_null_count
					);
					lu__assert(n_cell);

					lu_w_cell__save(curr_w_cell, n_cell, n_column);

					++cells_saved_count;

					curr_w_table->any_fired = true;
				}
			}
		}

		return curr_w_table;
	}

	// static Lu_W_Table lu_s_layer__frame_save(
	// 	Lu_S_Layer self,
	// 	lu_size rec_id,  
	// 	lu_size wave_id, 
	// 	lu_size block_id, 
	// 	Lu_W_Table prev_w_table, 
	// 	Lu_Process_Config config
	// )
	// {
	// 	lu__assert(self);
	// 	lu__assert(prev_w_table);

	// 	lu__assert(prev_w_table->wave_id == wave_id);
	// 	lu__assert(prev_w_table->block_id == block_id);

	// 	lu_size x;
	// 	lu_size y;

	// 	Lu_W_Table curr_w_table = lu_s_layer__get_w_table(self, wave_id);
	// 	lu__assert(curr_w_table);

	// 	curr_w_table->wave_id = wave_id;
	// 	curr_w_table->block_id = block_id;

	// 	lu_bool is_reset = prev_w_table->wave_id != wave_id || ((block_id - prev_w_table->block_id) > 1);

	// 	Lu_N_Table curr_n_table = self->n_table;
	// 	lu__assert(curr_n_table);

	// 	lu__assert(curr_n_table->w == curr_w_table->w);
	// 	lu__assert(curr_n_table->h == curr_w_table->h);

	// 	union lu_n_addr children[LU_N_CELL__CHILDREN_MAX];

	// 	lu_size cells_saved_count = 0;

	// 	Lu_W_Cell curr_w_cell;
	// 	union lu_n_addr n_addr;

	// 	curr_w_table->any_fired = false;

	// 	for (y = 0; y < curr_w_table->h; y++)
	// 	{
	// 		for (x = 0; x < curr_w_table->w; x++)
	// 		{
	// 			curr_w_cell = lu_w_table__get_w_cell(curr_w_table, x, y);
	// 			lu__debug_assert(curr_w_cell);

	// 			lu_w_cell__reset(curr_w_cell);

	// 			lu_w_table__cipher_children(prev_w_table, x, y, children);

	// 			if (lu_n_addr__is_present(&children[0]))
	// 			{
	// 				n_addr = lu_n_table__save_with_vp_children(curr_n_table, x, y, children);
	// 				lu_w_cell__save(curr_w_cell, n_addr);
	// 				++cells_saved_count;

	// 				curr_w_table->any_fired = true;
	// 			}
	// 		}
	// 	}

	// 	return curr_w_table;
	// }