/**
	Copyright Â© 2021 Oleh Ihorovych Novosad 
*/

	static Lu_S_Rec_Rg lu_s_rec_rg_create(Lu_S s, Lu_Rec rec)
	{
		lu_assert(s);
		lu_assert(rec);

		Lu_S_Rec_Rg self = (Lu_S_Rec_Rg) lu_g_mem_alloc(sizeof(struct lu_s_rec_rg));
		lu_assert(self);

		self->mem				= s;
		self->rec 				= rec;
		self->id 				= rec->id;

		self->cells_w 			= rec->width;
		self->cells_h			= rec->height; 
		self->cells_d 			= rec->depth;

		self->cells_count		= 0;
		self->cells_size 		= 0;

		self->cells_2_count 	= 0;
		self->cells_2_size 		= 0;

		self->cells_3_count 	= 0;
		self->cells_3_size 		= 0;

		///////////////////////////////////////
		// Confs

		lu_s_layer_conf_init(&self->v_conf, rec->config.v_min, rec->config.v_max, rec->config.v_neu_size);
		lu_s_layer_conf_init(&self->p_conf, rec->config.v_min, rec->config.v_max, rec->config.p_neu_size);

		///////////////////////////////////////
		// Allocate Lu_Data Layers

		self->data_layers_size = (self->cells_w > self->cells_h ? self->cells_w : self->cells_h);
		
		++self->data_layers_size; // + odyn dlia component 
																				
		self->data_layers = (struct lu_s_layer*) lu_g_mem_alloc(sizeof(struct lu_s_layer) * self->data_layers_size);
		lu_user_assert(self->data_layers, "Cannot allocate v layers"); 

		///////////////////////////////////////
		// Allocate Block Layers

		self->max_blocks_size 		= rec->config.max_blocks_size;
		self->block_layers_size 	= self->max_blocks_size + 1;	

		self->block_layers = (struct lu_s_layer*) lu_g_mem_alloc(sizeof(struct lu_s_layer) * self->block_layers_size);
		lu_user_assert(self->block_layers, "Cannot allocate av layers"); 

		///////////////////////////////////////
		// All layers init

		lu_s_rec_rg_layers_init(self);

		///////////////////////////////////////
		// Allocate cells

		self->cells = (struct lu_s_cell*) lu_g_mem_alloc(sizeof(struct lu_s_cell) * self->cells_size);
		lu_user_assert(self->cells, "Cannot allocate cells"); 

		self->cells_2 = (struct lu_s_cell_2*) lu_g_mem_alloc(sizeof(struct lu_s_cell_2) * self->cells_2_size);
		lu_user_assert(self->cells_2, "Cannot allocate cells"); 

		self->cells_3 = (struct lu_s_cell_3*) lu_g_mem_alloc(sizeof(struct lu_s_cell_3) * self->cells_3_size);
		lu_user_assert(self->cells_3, "Cannot allocate cells"); 

		///////////////////////////////////////
		// Init cells

		lu_s_rec_rg_components_init(self);
		lu_s_rec_rg_pixels_init(self);
		lu_s_rec_rg_pyras_init(self);
		lu_s_rec_rg_blocks_init(self);

		//lu_debug("\nneus_count = %d, cells_size = %d, rw=%d, rh=%d, rd=%d", self->cells_count, self->cells_size, self->cells_w, self->cells_h, self->cells_d);

		lu_user_assert(self->cells_count == self->cells_size, "Something wrong with cells_count");
		lu_user_assert(self->cells_2_count == self->cells_2_size, "Something wrong with cells_2_count");
		lu_user_assert(self->cells_3_count == self->cells_3_size, "Something wrong with cells_3_count");

		return self;
	}

	static void lu_s_rec_rg_destroy(Lu_S_Rec_Rg self)
	{
		lu_assert(self); 

		lu_s_rec_rg_blocks_deinit(self);
		lu_s_rec_rg_pyras_deinit(self);
		lu_s_rec_rg_pixels_deinit(self);
		lu_s_rec_rg_components_deinit(self);

		lu_s_rec_rg_layers_deinit(self);

		lu_s_layer_conf_deinit(&self->p_conf);
		lu_s_layer_conf_deinit(&self->v_conf);

		lu_g_mem_free((lu_p_byte) self->cells_3);
		lu_g_mem_free((lu_p_byte) self->cells_2);
		lu_g_mem_free((lu_p_byte) self->cells);
		lu_g_mem_free((lu_p_byte) self->block_layers);
		lu_g_mem_free((lu_p_byte) self->data_layers);

		lu_g_mem_free((lu_p_byte) self);
	}

	/*
	** Allocate space for Lu_S_Cell
	*/
	static Lu_S_Cell lu_s_rec_rg_cell_assign(Lu_S_Rec_Rg self, Lu_S_Layer layer)
	{
		lu_user_assert(self->cells_count < self->cells_size, "Out of space for Lu_S_Cell");

		Lu_S_Cell neu = &self->cells[self->cells_count];
		neu = lu_s_cell_init(neu, LU_SCT_CELL, layer, layer->cells_count);
		lu_user_assert(neu, "Cannot init Lu_S_Cell");

		lu_s_layer_cell_set(layer, 0, 0, 0, neu);

		// no need for lock, they are created once in one thread
		++layer->cells_count;
		++self->cells_count;

		return neu;
	}  

	static void lu_s_rec_rg_cell_retract(Lu_S_Rec_Rg self, Lu_S_Cell cell)
	{
		lu_s_cell_deinit(cell);
	}

	static Lu_S_Cell_2 lu_s_rec_rg_cell_2_assign(Lu_S_Rec_Rg self, Lu_S_Layer layer, lu_size x, lu_size y)
	{
		lu_user_assert(self->cells_2_count < self->cells_2_size, "Out of space for Lu_S_Cell_2");

		Lu_S_Cell_2 neu = &self->cells_2[self->cells_2_count];
		neu = lu_s_cell_2_init(neu, LU_SCT_CELL_2, layer, layer->cells_count, x, y);
		lu_user_assert(neu, "Cannot init Lu_S_Cell_2");

		lu_s_layer_cell_set(layer, x, y, 0, (Lu_S_Cell) neu);

		// no need for lock, they are created once in one thread
		++layer->cells_count;
		++self->cells_2_count;

		return neu;
	}

	static void lu_s_rec_rg_cell_2_retract(Lu_S_Rec_Rg self, Lu_S_Cell_2 cell)
	{
		lu_s_cell_2_deinit(cell);
	}

	static Lu_S_Cell_3 lu_s_rec_rg_cell_3_assign(Lu_S_Rec_Rg self, Lu_S_Layer layer, lu_size x, lu_size y, lu_size z)
	{
		lu_user_assert(self->cells_3_count < self->cells_3_size, "Out of space for Lu_S_Cell_3");

		Lu_S_Cell_3 neu = &self->cells_3[self->cells_3_count];
		neu = lu_s_cell_3_init(neu, layer, layer->cells_count, x, y, z);
		lu_user_assert(neu, "Cannot init Lu_S_Cell_3");

		lu_s_layer_cell_set(layer, x, y, z, (Lu_S_Cell) neu);

		// no need for lock, they are created once in one thread
		++layer->cells_count;
		++self->cells_3_count;

		return neu;
	}

	static void lu_s_rec_rg_cell_3_retract(Lu_S_Rec_Rg self, Lu_S_Cell_3 cell)
	{
		lu_s_cell_3_deinit(cell);
	}

	static void lu_s_rec_rg_print_layers_info(struct lu_s_layer* layers, lu_size size, lu_size print_top_size)
	{
		if (size < 1) return;
		if (size < print_top_size) print_top_size = size;
		Lu_S_Layer layer;

		for (lu_size i = 0; i < print_top_size; i++)
		{
			layer = &layers[i];
	 		lu_s_layer_print_info(layer);
		}
 		 
		lu_size print_last = size > print_top_size ? 1 : 0;

 		if (size > print_top_size)
 			lu_debug("\n 	 	.. %lu .. (total: %lu)", size - print_top_size - print_last, size);	

 		if (print_last)
 		{
			layer = &layers[size - 1];
 			lu_s_layer_print_info(layer);
 		}
	}


	static void lu_s_rec_rg_print_info(Lu_S_Rec_Rg self)
	{
		lu_user_assert_void(self, "Lu_S_Rec_Rg is NULL");

		lu_debug("\n\n 	-- Lu_S_Rec_Rg #%lu info: ", self->id);
 		lu_debug("\n 	 	%-19s %lu", "cells_w:", self->cells_w);
 		lu_debug("\n 	 	%-19s %lu", "cells_h:", self->cells_h);
 		lu_debug("\n 	 	%-19s %lu", "cells_d:", self->cells_d);
 		lu_debug("\n 	 	");
 		lu_debug("\n 	 	%-19s %lu", "cells_size:", self->cells_size);
 		lu_debug("\n 	 	%-19s %lu", "cells_count:", self->cells_count);
 		lu_debug("\n 	 	%-19s %lu", "cells_2_size:", self->cells_2_size);
 		lu_debug("\n 	 	%-19s %lu", "cells_2_count:", self->cells_2_count);
 		lu_debug("\n 	 	%-19s %lu", "cells_3_size:", self->cells_3_size);
 		lu_debug("\n 	 	%-19s %lu", "cells_3_count:", self->cells_3_count);
 		lu_debug("\n 	 	%-19s %lu", "data_layers_size:", self->data_layers_size);
 		lu_debug("\n 	 	%-19s %lu", "max_blocks_size:", self->max_blocks_size);
 		lu_debug("\n 	 	%-19s %lu", "block_layers_size:", self->block_layers_size);
 		lu_debug("\n 	 	");

 		lu_s_rec_rg_print_layers_info(self->data_layers, self->data_layers_size, 3);

		lu_debug("\n"); 
		
 		lu_s_rec_rg_print_layers_info(self->block_layers, self->block_layers_size, 1);
	}