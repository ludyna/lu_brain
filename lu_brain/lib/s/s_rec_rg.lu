/**
	Copyright Â© 2021 Oleh Ihorovych Novosad 
*/

	static Lu_S_Rec_Rg lu_s_rec_rg_create(Lu_Rec rec, Lu_S_Cell_Mem cell_mem)
	{
		lu_assert(rec);
		lu_assert(cell_mem);

		Lu_S_Rec_Rg self = (Lu_S_Rec_Rg) lu_mem_alloc(sizeof(struct lu_s_rec_rg));
		lu_assert(self);

		self->rec 				= rec;
		self->id 				= rec->id;

		self->cells_w 			= rec->width;
		self->cells_h			= rec->height; 
		self->cells_d 			= rec->depth; 

		self->cell_mem 			= cell_mem;

		//
		// Component layers inits
		//

		lu_s_component_layer_init(&self->v_layer, rec->config.v_min, rec->config.v_max, rec->config.v_neu_size);
		lu_s_component_layer_init(&self->p_layer, rec->config.v_min, rec->config.v_max, rec->config.p_neu_size);

		//
		// Pixel layer init
		// 

		lu_s_pixel_layer_init(&self->pixel_layer, self->cells_w, self->cells_h);

		//
		// Rec layers allocate and init
		//

		self->rec_layers_size 	= (self->cells_w > self->cells_h ? self->cells_w : self->cells_h);

		// minus one for seq_rg
		// minus one for nertex layer 
		if (self->rec_layers_size < 3) 
		{
			// if pixel layer is too small, we skip rec_layers
			self->rec_layers 		= NULL;
			self->rec_layers_size 	= 0;
			return self;
		}
		else self->rec_layers_size -= 2;
			
		lu_assert(self->rec_layers_size > 0);

		lu_size w = self->cells_w - 1;
		lu_size h = self->cells_h - 1;				
		self->rec_layers = (struct lu_s_rec_layer*) lu_mem_alloc(sizeof(struct lu_s_rec_layer) * self->rec_layers_size);
		lu_assert(self->layers); 

		lu_size ix = 0;
		while (w >= 2 || h >= 2)
		{
			lu_assert(ix < rec_layers_size);

			// tip should be in seq_nx layer, not here
			lu_assert(w > 1 && h > 1);

			lu_s_rec_layer_init(&self->rec_layers[i], i, w, h);

			if (w > 1) --w;
			if (h > 1) --h;
			++ix; 
		}
	
		return self;
	}

	static void lu_s_rec_rg_destroy(Lu_S_Rec_Rg self)
	{
		lu_assert(self); 

		lu_s_rec_rg_pyras_layers_disconnect(self);
		lu_s_rec_rg_pixel_layer_disconnect(self);
		lu_s_rec_rg_component_layer_disconnect(self);

		lu_s_rec_rg_layers_deinit(self);

		lu_s_layer_conf_deinit(&self->p_conf);
		lu_s_layer_conf_deinit(&self->v_conf);

		if (self->rec_layers)
			lu_mem_free((lu_p_byte) self->rec_layers);

		lu_mem_free((lu_p_byte) self);
	}

	static void lu_s_rec_rg_print_layers_info(struct lu_s_layer* layers, lu_size size, lu_size print_top_size)
	{
		if (size < 1) return;
		if (size < print_top_size) print_top_size = size;
		Lu_S_Layer layer;

		for (lu_size i = 0; i < print_top_size; i++)
		{
			layer = &layers[i];
	 		lu_s_layer_print_info(layer);
		}
 		 
		lu_size print_last = size > print_top_size ? 1 : 0;

 		if (size > print_top_size)
 			lu_debug("\n 	 	.. %lu .. (total: %lu)", size - print_top_size - print_last, size);	

 		if (print_last)
 		{
			layer = &layers[size - 1];
 			lu_s_layer_print_info(layer);
 		}
	}


	static void lu_s_rec_rg_print_info(Lu_S_Rec_Rg self)
	{
		lu_assert(self);

		lu_debug("\n\n 	-- Lu_S_Rec_Rg #%lu info: ", self->id);
 		lu_debug("\n 	 	%-19s %lu", "cells_w:", self->cells_w);
 		lu_debug("\n 	 	%-19s %lu", "cells_h:", self->cells_h);
 		lu_debug("\n 	 	%-19s %lu", "cells_d:", self->cells_d);
 		lu_debug("\n 	 	");
 		
 		lu_debug("\n 	 	%-19s %lu", "layers_size:", self->layers_size);
 		lu_debug("\n 	 	");

 		lu_s_rec_rg_print_layers_info(self->layers, self->layers_size, 3);

		lu_debug("\n"); 
	}