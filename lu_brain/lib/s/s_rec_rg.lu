/**
	Copyright Â© 2021 Oleh Ihorovych Novosad 
*/

	static Lu_S_Rec_Rg lu_s_rec_rg_create(Lu_Mem mem, Lu_Rec rec, Lu_S_Cell_Mem cell_mem)
	{
		lu_assert(mem);
		lu_assert(rec);
		lu_assert(cell_mem);

		Lu_S_Rec_Rg self = (Lu_S_Rec_Rg) lu_mem_alloc(mem, sizeof(struct lu_s_rec_rg));
		lu_assert(self);

		lu_s_base_rg_init(&self->super, mem, cell_mem);

		self->rec 				= rec;
		self->id 				= rec->id;

		self->cells_w 			= rec->width;
		self->cells_h			= rec->height; 
		self->cells_d 			= rec->depth; 

		//
		// Component layers inits
		//

		lu_s_component_layer_init(
			&self->v_layer, 
			mem, 
			self->cells_w,
			self->cells_h,
			self->cells_d,
			rec->config.v_min, 
			rec->config.v_max, 
			rec->config.v_neu_size
		);

		lu_s_component_layer_init(
			&self->p_layer, 
			mem, 
			self->cells_w,
			self->cells_h,
			self->cells_d,
			rec->config.v_min, 
			rec->config.v_max, 
			rec->config.p_neu_size
		);

		//
		// Pixel layer init
		// 

		lu_s_pixel_layer_init(&self->pixel_layer, mem, self->cells_w, self->cells_h);

		//
		// Rec layers allocate and init
		//

		self->rec_layers_size 	= (self->cells_w > self->cells_h ? self->cells_w : self->cells_h);

		// minus one for seq_rg
		// minus one for nertex layer 
		if (self->rec_layers_size < 3) 
		{
			// if pixel layer is too small, we skip rec_layers
			self->rec_layers 		= NULL;
			self->rec_layers_size 	= 0;
			return self;
		}
		else self->rec_layers_size -= 2;
			
		lu_assert(self->rec_layers_size > 0);

		lu_size w = self->cells_w - 1;
		lu_size h = self->cells_h - 1;				
		self->rec_layers = (struct lu_s_rec_layer*) lu_mem_alloc(mem, sizeof(struct lu_s_rec_layer) * self->rec_layers_size);
		lu_assert(self->rec_layers); 

		lu_size ix = 0;
		while (w >= 2 || h >= 2)
		{
			lu_assert(ix < self->rec_layers_size);

			// tip should be in seq_nx layer, not here
			lu_assert(w > 1 && h > 1);

			lu_s_rec_layer_init(&self->rec_layers[ix], mem, ix, w, h);

			if (w > 1) --w;
			if (h > 1) --h;
			++ix; 
		}
	
		return self;
	}

	static void lu_s_rec_rg_destroy(Lu_S_Rec_Rg self)
	{
		lu_assert(self);
		lu_assert(self->super.mem);

		for(lu_size i = 0; i < self->rec_layers_size; i++)
		{
			lu_s_rec_layer_deinit(&self->rec_layers[i]);
		}

		if (self->rec_layers)
			lu_mem_free(self->super.mem, (lu_p_byte) self->rec_layers);


		lu_s_pixel_layer_deinit(&self->pixel_layer);

		lu_s_component_layer_deinit(&self->p_layer);
		lu_s_component_layer_deinit(&self->v_layer);

		lu_s_base_rg_deinit(&self->super);

		lu_mem_free(self->super.mem, (lu_p_byte) self);
	}


	static void lu_s_rec_rg_print_info(Lu_S_Rec_Rg self)
	{
		lu_assert(self);

		// lu_debug("\n\n 	-- Lu_S_Rec_Rg #%lu info: ", self->id);
 	// 	lu_debug("\n 	 	%-19s %lu", "cells_w:", self->cells_w);
 	// 	lu_debug("\n 	 	%-19s %lu", "cells_h:", self->cells_h);
 	// 	lu_debug("\n 	 	%-19s %lu", "cells_d:", self->cells_d);
 	// 	lu_debug("\n 	 	");
 		
 	// 	lu_debug("\n 	 	%-19s %lu", "layers_size:", self->layers_size);
 	// 	lu_debug("\n 	 	");

 	// 	lu_s_rec_rg_print_layers_info(self->layers, self->layers_size, 3);

		lu_debug("\n"); 
	}