/**
	Copyright Â© 2021 Oleh Ihorovych Novosad 
*/


///////////////////////////////////////////////////////////////////////////////
// Lu_S Create & Destroy

	static Lu_S lu_s__create(Lu_Mem mem, struct lu_space_config config, Lu_Arr recs)
	{
		lu__assert(mem);
		lu__assert(recs);
		lu__assert(lu_arr__count(recs) > 0);

		Lu_S self = (Lu_S) lu_mem__alloc(mem, sizeof(struct lu_s));
		lu__assert(self);

		Lu_Space_Config v_config = lu_space_config__validate(&config);
		lu__assert(v_config);

		self->config = *v_config;
		self->mem = mem;

		//
		// Cell_Mem_Config
		//

		// struct lu_s_layer_mem_config cell_mem_config;

		// lu_s_cell_mem_config__init(&cell_mem_config);

		//
		// 
		//

		lu__assert(self->config.frames_size >= lu_arr__count(recs));

		self->frames = lu_arr__create(mem, self->config.frames_size, true);
		lu__assert(self->frames);

		self->apexes = lu_arr__create(mem, self->config.apexes_size, true);
		lu__assert(self->apexes);


		// User actions must be done to increase layers in levels
		// For example, we do not allow to increase layer frames
		// To increase recs we need to add rec
		// To increase seq we need to add time frame
		// To increase event we need to add event
		// To increase scene we need to add scene
		// To increase story we need to add story, etc.

		// lu_size i;1
		// Lu_S_Frame_Layer frame;
		// for (i = 0; i < lu_arr__count(recs); i++)
		// {
		// 	Lu_Rec lu_rec = (Lu_Rec) lu_arr__get(recs, i);
		// 	lu__assert(lu_rec);

		// 	frame = lu_s_frame_layer__create(mem, lu_rec);
		// 	lu__assert(frame);
		// 	lu_arr__append(self->frames, frame);
		// }

		lu_s__create_min_fractal(self, recs);
	
		// we start apexes from frame, since 

		return self;
	}

	static void lu_s__destroy(Lu_S self)
	{
		lu__assert(self);
		lu__assert(self->mem);

		if (self->apexes) 
		{
			Lu_S_Layer apex = lu_arr__last(self->apexes);

			if (apex)
			{
				lu_s_layer__destroy(apex, self->mem);
			}

			lu_arr__destroy(self->apexes);
		}

		if (self->frames)
			lu_arr__destroy(self->frames);


		lu_mem__free(self->mem, (lu_p_byte) self);
	}

///////////////////////////////////////////////////////////////////////////////
// Lu_S Methods

	// Min fractal:
	//
	// 		layer seq (sv: seq_count, sh: 1, nh: n)
	// 		layer recs (sv: rec_count)
	// 		layer frames/pixels (sv: (w Y h), sh: 1, nh: n)
	// 		omp1 comp2 comp3 (sv: 1, sh: comp_count or d, n: w x h)
	//
	//
	//		|  
	//		| layer seq: sv: seq_count (for min fractal seq_count = 1)
	//		|
	//		- (we could do //// seq_count but we want seqs be independent of seq position
	//		|
	//		| layer recs: recs_count
	//		|
	//		-
	//	  / / / / (sh: recs_count, here n data is totally independent of each other, thats why sh: recs_count)
	//	  | | | |
	//	  | | | | (w Y h)i, where i is rec id
	//	  | | | |
	//	  / . . \
	//	 /       \
	//	/         \
	// / / /      \ \ \ (sv 1, sh: comp_count, n independent of each other)

	static Lu_S_Layer_Base lu_s__create_min_fractal(Lu_S self, Lu_Arr recs)
	{
		lu__assert(self);
		lu__assert(recs);
		lu__assert(self->apexes);
		lu__assert(self->frames);

		//
		// seq layers
		//

		// self->apexes[4] = 



		//
		// recs layers
		// 

		//
		// frames fractals
		//





		Lu_S_Layer seq_layer = lu_s_layer__create(self->mem, LU_S_LT_LAYER, 4);

		lu_size i;
		Lu_S_Layer_Base parent = (Lu_S_Layer_Base) seq_layer;
		Lu_S_Layer_Base child = NULL;
		lu_size j;

		lu_s_layer_base__create_and_attach_multi_slot((Lu_S_Layer_Base) seq_layer, );

		for (i = 0; i < lu_arr__count(recs); i++)
		{
			child = lu_s_layer__create(self->mem, LU_S_LT_LAYER, 3);
		}

		Lu_S_Layer recs_layer = lu_s_layer__create(self->mem,  3);

		
		return (Lu_S_Layer_Base) seq_layer;
	}

	static Lu_S_Layer_Base lu_s__create_vert_layers(
		Lu_S self, 
		enum lu_s_layer_type layer_type, 
		lu_size level, 
		lu_size count
	)
	{

	}

	static Lu_S_Layer_Base lu_s__create_frame_fractal(Lu_S self, Lu_Rec rec)
	{

	}




	static void lu_s__print_info(Lu_S self)
	{
		// lu__user_assert_void(self, "Lu_S is NULL");
		// lu__user_assert_void(self->recs, "Lu_S recs is NULL");

 	// 	lu__debug("\n\n-- Lu_S info: ");
 	// 	lu__debug("\n 	Lu_S_Rec_Rg count: %lu", lu_arr__count(self->recs));

 	// 	Lu_S_Rec_Rg rec;
 	// 	lu_size i;
 	// 	for(i = 0; i < lu_arr__count(self->recs); i++)
 	// 	{
 	// 		rec = (Lu_S_Rec_Rg) lu_arr__get(self->recs, i);
 	// 		if (rec) 
 	// 			lu_s_rec_rg__print_info(rec);
 	// 	}
	}
