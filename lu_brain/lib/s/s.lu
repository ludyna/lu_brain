/**
	Copyright Â© 2022 Oleh Ihorovych Novosad 
*/


///////////////////////////////////////////////////////////////////////////////
// Lu_S Create & Destroy

	static Lu_S lu_s__create_intersected_squares_cortex(Lu_Mem mem, struct lu_space_config config, Lu_Arr recs)
	{
		lu__assert(mem);
		lu__assert(recs);
		lu__assert(lu_arr__count(recs) > 0);

		Lu_S self = (Lu_S) lu_mem__alloc(mem, sizeof(struct lu_s));
		lu__assert(self);

		Lu_Space_Config v_config = lu_space_config__validate(&config);
		lu__assert(v_config);

		self->config = *v_config;
		self->mem = mem;

		lu__assert(self->config.frames_size >= lu_arr__count(recs));

		self->frames = lu_arr__create(self->mem, self->config.frames_size, true);
		lu__assert(self->frames);

		Lu_Rec rec;
		lu_size i;
		lu_size j;
		Lu_S_Map_Frame frame_map;
		Lu_S_Map_Story story_map;
		Lu_S_Layer_Frame frame;

		story_map = lu_s_map_story__create(mem, lu_arr__count(recs)); 
		lu__assert(story_map);

		lu_s_map_base__make_story_fractal((Lu_S_Map_Base) story_map, story_map->recs_count);

		Lu_S_Layer_Base recs_base = lu_s_map_base__get_base((Lu_S_Map_Base) story_map);
		lu__assert(recs_base);


		Lu_S_Layer_Base frame_apex;
		for (i = 0; i < lu_arr__count(recs); i++)
		{
			rec = (Lu_Rec) lu_arr__get(recs, i);
			lu__assert(rec);

			frame_map = lu_s_map_frame__create(mem, rec, (Lu_S_Map_Base) story_map);
			lu__assert(frame_map->super.type == LU_S_MT__FRAME);
			lu__assert(frame_map);

			lu_s_map_base__make_frame_fractal((Lu_S_Map_Base) frame_map, frame_map->rec);

			frame = lu_s_map_base__get_frame((Lu_S_Map_Base) frame_map);
			lu__assert(frame);

			// save pointer to frame
			lu_arr__set(self->frames, i, (lu_p_void) frame);

			// connect layers
			frame_apex = lu_s_map_base__get_apex((Lu_S_Map_Base) frame_map);
			lu_s_layer_base__connect(recs_base, frame_apex);

			// connect maps
			lu_s_map_base__connect((Lu_S_Map_Base) story_map, (Lu_S_Map_Base) frame_map);
		}

		return self;
	}

	static void lu_s__destroy(Lu_S self)
	{
		lu__assert(self);
		lu__assert(self->mem);

		// if (self->apexes) 
		// {

		// 	lu_size apexes_count = lu_arr__count(self->apexes);

		// 	Lu_Slot_Base slot_base;

		// 	if (apexes_count)
		// 	{
		// 		//
		// 		// Destroy s frame_map
		// 		//

		// 		slot_base = (Lu_Slot_Base) lu_arr__last(self->apexes);
		// 		lu__assert(slot_base);

		// 		// Last one should be always SINGLE apex
		// 		lu__assert(slot_base->type == LU_ST__ONE);

		// 		Lu_Slot_One apex = (Lu_Slot_One) slot_base;
		// 		lu__assert(apex->item);

		// 		Lu_S_Layer_Base layer_base = (Lu_S_Layer_Base) apex->item;

		// 		// Last layer should be always LU_S_LT__LAYER
		// 		lu__assert(layer_base->type == LU_S_LT__LAYER);

		// 		lu_s__destroy_fractal(self->mem, layer_base);
		// 	}

		// 	//
		// 	// Destroy apexes
		// 	//

		// 	for (lu_size i = 0; i < apexes_count; i++)
		// 	{
		// 		slot_base = (Lu_Slot_Base) lu_arr__get(self->apexes, i); 
		// 		lu__assert(slot_base);
		// 		lu__assert(slot_base->destroy);

		// 		slot_base->destroy(slot_base, self->mem);
		// 	}

		// 	//
		// 	// Destroy array
		// 	//

		// 	lu_arr__destroy(self->apexes);
		// }

		if (self->frames)
			lu_arr__destroy(self->frames);

		lu_mem__free(self->mem, (lu_p_byte) self);
	}

///////////////////////////////////////////////////////////////////////////////
// Lu_S Fractals
//
// User actions must be done to increase layers in levels
// For example, we do not allow to increase layer frames
// To increase recs we need to add rec
// To increase seq we need to add time frame
// To increase event we need to add event
// To increase scene we need to add scene
// To increase story we need to add story, etc.
//
// "Minimal" start:
//
// 		6 level3, story(vertically 1-n4)
// 		5 level2, scene(vertically 1-n3)
// 		4 level1, event (vertically 1-n2)
// 		3 layer seq (vertically 1-n1)
// 		2 layer recs (vertically rec_count)
// 		1 layer rixel (vertically w Y h)
// 		0 frame(vertically 1) 
// 		- comp1 comp2 comp3 (horizontally comp_count or d)
//
// 
//
// 		layer seq (sv: seq_count, sh: 1, nh: n)
// 		layer recs (sv: rec_count)
// 		layer frames/pixels (sv: (w Y h), sh: 1, nh: n)
// 		omp1 comp2 comp3 (sv: 1, sh: comp_count or d, n: w x h)
//
//
//		|  
//		| layer seq: sv: seq_count (for min frame_map seq_count = 1)
//		|
//		- (we could do //// sh: seq_count but we want seqs be independent of seq position
//		|
//		| layer recs: recs_count
//		|
//		-
//	  / / / / frame (sh: recs_count, here n data is totally independent of each other, thats why sh: recs_count)
//	  | | | |
//	  | | | | (w Y h)i, where i is rec id
//	  | | | |
//	  / . . \
//	 /       \
//	/         \
// / / /      \ \ \ (sv 1, sh: comp_count, n independent of each other)


	static void lu_s__add_v_layer(Lu_S self, lu_size level)
	{

	}

	static void lu_s__add_h_layer(Lu_S self, lu_size level)
	{

	}

	static void lu_s__add_frame(Lu_S self, Lu_Rec rec)
	{

	}

	static void lu_s__create_story_fractal(Lu_Mem mem, Lu_S_Layer p, Lu_Arr apexes, Lu_Arr frames, Lu_Arr recs)
	{  
		lu__assert(mem);
		lu__assert(apexes);
		lu__assert(frames);
		lu__assert(recs);

		Lu_S_Layer layer = lu_s_layer__create(mem, 7, 1);
		lu__assert(layer);

		Lu_Slot_One slot = lu_slot_one__create(mem, (lu_p_void) layer);
		lu__assert(slot);

		// if (p)
		// {
		// 	lu_s_layer_base__connect((Lu_S_Layer_Base) p, (Lu_S_Layer_Base) layer);
		// }

		lu_arr__append(apexes, (lu_p_void) slot);

		lu_s__create_scene_fractal(mem, layer, apexes, frames, recs);
	}


	static void lu_s__create_scene_fractal(Lu_Mem mem, Lu_S_Layer p, Lu_Arr apexes, Lu_Arr frames, Lu_Arr recs)
	{
		lu__assert(mem);
		lu__assert(apexes);
		lu__assert(frames);
		lu__assert(recs);

		Lu_S_Layer layer = lu_s_layer__create(mem, 6, 1);
		lu__assert(layer);

		Lu_Slot_One slot = lu_slot_one__create(mem, (lu_p_void) layer);
		lu__assert(slot);

		if (p)
		{
			lu_s_layer_base__connect((Lu_S_Layer_Base) p, (Lu_S_Layer_Base) layer);
		}

		lu_arr__append(apexes, (lu_p_void) slot);

		lu_s__create_event_fractal(mem, layer, apexes, frames, recs);
	}

	static void lu_s__create_event_fractal(Lu_Mem mem, Lu_S_Layer p, Lu_Arr apexes, Lu_Arr frames, Lu_Arr recs)
	{
		lu__assert(mem);
		lu__assert(apexes);
		lu__assert(frames);
		lu__assert(recs);

		Lu_S_Layer layer = lu_s_layer__create(mem, 5, 1);
		lu__assert(layer);

		Lu_Slot_One slot = lu_slot_one__create(mem, (lu_p_void) layer);
		lu__assert(slot);

		if (p)
			lu_s_layer_base__connect((Lu_S_Layer_Base) p, (Lu_S_Layer_Base) layer);

		lu_arr__append(apexes, (lu_p_void) slot);

		lu_s__create_seq_fractal(mem, layer, apexes, frames, recs);
	}

	static void lu_s__create_seq_fractal(Lu_Mem mem, Lu_S_Layer p, Lu_Arr apexes, Lu_Arr frames, Lu_Arr recs)
	{
		lu__assert(mem);
		lu__assert(apexes);
		lu__assert(frames);
		lu__assert(recs);

		Lu_S_Layer layer = lu_s_layer__create(mem, 4, 1);
		lu__assert(layer);

		Lu_Slot_One slot = lu_slot_one__create(mem, (lu_p_void) layer);
		lu__assert(slot);
		
		if (p)
			lu_s_layer_base__connect((Lu_S_Layer_Base) p, (Lu_S_Layer_Base) layer);

		lu_arr__append(apexes, (lu_p_void) slot);

		lu_s__create_rec_fractal(mem, layer, apexes, frames, recs);
	}

	static void lu_s__create_rec_fractal(Lu_Mem mem, Lu_S_Layer p, Lu_Arr apexes, Lu_Arr frames, Lu_Arr recs)
	{
		lu__assert(mem);
		lu__assert(apexes);
		lu__assert(frames);
		lu__assert(recs);
 
		// lu_size i;
		// lu_size count = lu_arr__count(recs);
		// Lu_S_Layer layer = NULL;
		// Lu_S_Layer prev = p;

		// for(i = 0; i < count; i++)
		// {
 	// 		layer = lu_s_layer__create(mem, 3);
 	// 		lu__assert(layer);

		// 	if (prev)
		// 		lu_s_layer__connect(prev, layer);

		// 	// Only first one is apex
		// 	if (i == 0)
		// 		lu_arr__append(apexes, (lu_p_void) layer);

		// 	prev = layer;
		// }

		// lu_s__create_frame_fractal(mem, layer, apexes, frames, recs);
	}  

	static void lu_s__create_frame_fractal(Lu_Mem mem, Lu_S_Layer p, Lu_Arr apexes, Lu_Arr frames, Lu_Rec rec)
	{

	}

	static void lu_s__create_component_fractal(Lu_Mem mem, Lu_S_Layer_Frame p, Lu_Arr apexes, Lu_Rec rec)
	{

	}

	static void lu_s__destroy_fractal(Lu_Mem mem, Lu_S_Layer_Base layer)
	{
		lu__assert(mem);
		lu__assert(layer);
		lu__assert(layer->destroy);

		if (layer->c)
		{
			if (layer->c->type == LU_ST__ONE)
			{
				Lu_Slot_One one = (Lu_Slot_One) layer->c;

				if (one->item)
				{
					lu_s__destroy_fractal(mem, (Lu_S_Layer_Base) one->item);
				}
			}
			else if (layer->c->type == LU_ST__ARR)
			{
				Lu_Slot_Arr slot_arr = (Lu_Slot_Arr) layer->c;

				if (slot_arr->items)
				{

					Lu_Arr arr = slot_arr->items;

					for (lu_size i = 0; i < lu_arr__count(arr); i++)
					{
						Lu_S_Layer_Base c_layer = (Lu_S_Layer_Base) lu_arr__get(arr, i);
						if (c_layer)
						{
							lu_s__destroy_fractal(mem, c_layer);
						}
					}
				}
			}
			else
			{
				lu__assert(0);
			}
		}

		layer->destroy(layer, mem);
	}

	static Lu_S_Layer_Base lu_s__create_vert_layers(
		Lu_S self, 
		enum lu_s_layer_type layer_type, 
		lu_size level, 
		lu_size count
	)
	{

	}


///////////////////////////////////////////////////////////////////////////////
// 


	static void lu_s__print_info(Lu_S self)
	{
		// lu__user_assert_void(self, "Lu_S is NULL");
		// lu__user_assert_void(self->recs, "Lu_S recs is NULL");

 	// 	lu__debug("\n\n-- Lu_S info: ");
 	// 	lu__debug("\n 	Lu_S_Rec_Rg count: %lu", lu_arr__count(self->recs));

 	// 	Lu_S_Rec_Rg rec;
 	// 	lu_size i;
 	// 	for(i = 0; i < lu_arr__count(self->recs); i++)
 	// 	{
 	// 		rec = (Lu_S_Rec_Rg) lu_arr__get(self->recs, i);
 	// 		if (rec) 
 	// 			lu_s_rec_rg__print_info(rec);
 	// 	}
	}
