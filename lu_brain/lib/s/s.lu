/**
	Copyright Â© 2022 Oleh Ihorovych Novosad 
*/


///////////////////////////////////////////////////////////////////////////////
// Lu_S Create & Destroy

	static Lu_S lu_s__create_intersected_squares_cortex(
		Lu_Config config, 
		Lu_Arr recs
	)
	{
		lu__assert(config);
		lu__assert(recs);
		lu__assert(lu_arr__count(recs) > 0);

		Lu_S self = (Lu_S) lu_mem__alloc(config->s_mem, sizeof(struct lu_s));
		lu__assert(self);

		Lu_Config v_config = lu_config__validate(config);
		lu__assert(v_config);

		self->config = v_config;

		lu_size i;

		// (!!) This is important. We start layers ixs from LU_N_CELL__SPEIAL_CELLS_SKIP, 
		// so union lu_n_addr.value = 0 will be reserved as "NULL" cell. 
		// This way will not need "special cells", instead we can refer to non existent special layers.
		// It will save memory and will make code more straightforward.
		// To form addr of special cell we can use layer_ix from < LU_N_CELL__SPEIAL_CELLS_SKIP, 
		// and appropriate x and y to form column_ix. cell_x can be 0.
		self->layers_count = LU_N_CELL__SPEIAL_CELLS_SKIP;
		for(i = 0; i < LU_N_CELL__SPEIAL_CELLS_SKIP; i++)
		{
			self->layers[i] = NULL;
		}

		self->v_recs = lu_arr__create(config->s_mem, lu_arr__count(recs), true);
		lu__assert(self->v_recs);

		Lu_Rec rec;
		lu_size j;
		Lu_S_Map_Frame frame_map;
		Lu_S_Map_Story story_map;
		Lu_S_Layer_Rec frame;

		story_map = lu_s_map_story__create(lu_arr__count(recs), config); 
		lu__assert(story_map);

		lu_s_map_base__make_story_fractal((Lu_S_Map_Base) story_map, story_map->recs_count, self);

		Lu_S_Layer_Base recs_base = lu_s_map_base__get_base((Lu_S_Map_Base) story_map);
		lu__assert(recs_base);

		Lu_S_Layer_Base frame_apex;
		for (i = 0; i < lu_arr__count(recs); i++)
		{
			rec = (Lu_Rec) lu_arr__get(recs, i);
			lu__assert(rec);

			frame_map = lu_s_map_frame__create(rec, (Lu_S_Map_Base) story_map, config);
			lu__assert(frame_map->super.type == LU_S_MAP__FRAME);
			lu__assert(frame_map);

			lu_s_map_base__make_rec_fractal((Lu_S_Map_Base) frame_map, frame_map->rec, self);

			frame = lu_s_map_base__get_frame((Lu_S_Map_Base) frame_map);
			lu__assert(frame);

			// save pointer to frame
			lu_arr__set(self->v_recs, i, (lu_p_void) frame);

			// connect layers
			frame_apex = lu_s_map_base__get_apex((Lu_S_Map_Base) frame_map);
			lu__assert(frame_apex);

			lu_s_layer_base__connect(recs_base, frame_apex);

			// connect maps
			lu_s_map_base__connect((Lu_S_Map_Base) story_map, (Lu_S_Map_Base) frame_map);
		}

		self->fractal = (Lu_S_Map_Base) story_map;

		return self;
	}

	static void lu_s__destroy(Lu_S self)
	{
		lu__assert(self);
		lu__assert(self->config);

		if (self->fractal)
		{
			Lu_S_Layer_Base layer_base = lu_s_map_base__get_apex(self->fractal);

			if (layer_base)
			{
				lu__assert(layer_base->destroy);

				lu_s_layer_base__recursive_destroy(layer_base);
			}

			lu_s_map_base__recursive_destroy(self->fractal);
		}

		if (self->v_recs)
			lu_arr__destroy(self->v_recs);

		lu_mem__free(self->config->s_mem, (lu_p_byte) self);
	}

///////////////////////////////////////////////////////////////////////////////
// Lu_S Fractals
//
// User actions must be done to increase layers in levels
// For example, we do not allow to increase layer frames
// To increase recs we need to add rec
// To increase seq we need to add time frame
// To increase event we need to add event
// To increase scene we need to add scene
// To increase story we need to add story, etc.
//
// "Minimal" start:
//
// 		6 level3, story(vertically 1-n4)
// 		5 level2, scene(vertically 1-n3)
// 		4 level1, event (vertically 1-n2)
// 		3 layer seq (vertically 1-n1)
// 		2 layer recs (vertically rec_count)
// 		1 layer rixel (vertically w Y h)
// 		0 frame(vertically 1) 
// 		- comp1 comp2 comp3 (horizontally comp_count or d)
//
// 
//
// 		layer seq (sv: seq_count, sh: 1, nh: n)
// 		layer recs (sv: rec_count)
// 		layer frames/pixels (sv: (w Y h), sh: 1, nh: n)
// 		omp1 comp2 comp3 (sv: 1, sh: comp_count or d, n: w x h)
//
//
//		|  
//		| layer seq: sv: seq_count (for min frame_map seq_count = 1)
//		|
//		- (we could do //// sh: seq_count but we want seqs be independent of seq position
//		|
//		| layer recs: recs_count
//		|
//		-
//	  / / / / frame (sh: recs_count, here n data is totally independent of each other, thats why sh: recs_count)
//	  | | | |
//	  | | | | (w Y h)i, where i is rec id
//	  | | | |
//	  / . . \
//	 /       \
//	/         \
// / / /      \ \ \ (sv 1, sh: comp_count, n independent of each other)

///////////////////////////////////////////////////////////////////////////////
// 


	static Lu_S_Layer_Comp lu_s__create_layer_comp(
		Lu_S self, 
		Lu_Config config, 
		Lu_S_Layer_Rec frame, 
		Lu_Rec_Comp_Config rc_config
	)
	{
		lu__assert(self);
		lu__assert(config);
		lu__assert(frame);
		lu__assert(rc_config);
		lu__assert(self->layers_count < LU_S__LAYERS_SIZE);

		Lu_S_Layer_Comp layer = lu_s_layer_comp__create(config, frame, rc_config, self->layers_count);

		lu_s__register_layer(self, (Lu_S_Layer_Base) layer);

		return layer;
	}

	static Lu_S_Layer lu_s__create_layer(
		Lu_S self,
		Lu_Config config, 
		lu_size children_count,
		lu_size n_w,
		lu_size n_h,
		lu_size n_h_max,
		enum lu_s_layer_tag tag
	)
	{
		lu__assert(self);
		lu__assert(config);
		lu__assert(self->layers_count < LU_S__LAYERS_SIZE);
		lu__assert(n_w > 0);
		lu__assert(n_h > 0);

		Lu_S_Layer layer = lu_s_layer__create(
			config, 
			self->layers_count, 
			children_count, 
			n_w, 
			n_h, 
			n_h_max,
			tag
		);
	
		lu_s__register_layer(self, (Lu_S_Layer_Base) layer);

		return layer;
	}
	
	static Lu_S_Layer_Rec lu_s__create_layer_rec(
		Lu_S self,
		Lu_Config config, 
		Lu_Rec rec
	)
	{
		lu__assert(self);
		lu__assert(self->layers_count < LU_S__LAYERS_SIZE);
		lu__assert(config);
		lu__assert(rec);

		Lu_S_Layer_Rec layer = lu_s_layer_rec__create(config, rec, self->layers_count);
		
		lu_s__register_layer(self, (Lu_S_Layer_Base) layer); 

		return layer;
	}

///////////////////////////////////////////////////////////////////////////////
// 

	static void lu_s__print_info(Lu_S self)
	{
		lu__assert(self);

		Lu_S_Layer_Base layer;
		lu__debug("\n Lu_S layers: ");
		char buffer[50];
		for (lu_size i = LU_N_CELL__SPEIAL_CELLS_SKIP; i < self->layers_count; i++)
		{
			layer = self->layers[i];

			if (layer == NULL) break;

			lu__debug("\n 	layer_ix: %d", layer->layer_ix);
			lu_s_layer_type__to_str(layer->type, buffer);
			lu__debug("\n 	type: %s", buffer);
			lu_s_layer_tag__to_str(layer->tag, buffer);
			lu__debug("\n 	tag: %s", buffer);
			lu__debug("\n -------------- ");
		}

	}


	static void lu_s__save_rec_data(Lu_S self, Lu_Wave wave, lu_size rec_id, Lu_Data data, Lu_Process_Config config)
	{
		lu__assert(self);
		Lu_S_Layer_Rec frame = lu_s__get_v_rec(self, rec_id);
		lu__assert(frame);

		lu_s_layer_rec__save(frame, wave, rec_id, data, config);
	}