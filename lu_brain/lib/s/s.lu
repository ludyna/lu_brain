/**
	Copyright Â© 2021 Oleh Ihorovych Novosad 
*/


///////////////////////////////////////////////////////////////////////////////
// Lu_S Create & Destroy

	static Lu_S lu_s__create(Lu_Mem mem, struct lu_space_config config, Lu_Arr recs)
	{
		lu__assert(mem);
		lu__assert(recs);
		lu__assert(lu_arr__count(recs) > 0);

		Lu_S self = (Lu_S) lu_mem__alloc(mem, sizeof(struct lu_s));
		lu__assert(self);

		self->config = config;
		self->mem = mem;

		//
		// Cell_Mem_Config
		//

		// struct lu_s_layer_mem_config cell_mem_config;

		// lu_s_cell_mem_config__init(&cell_mem_config);

		//
		// 
		//

		self->frames = lu_arr__create(mem, self->config.frames_size, true);
		lu__assert(self->frames);

		// "Minimal" start:

		// level3, story(vertically 1-n4)
		// level2, scene(vertically 1-n3)
		// level1, event (vertically 1-n2)
		// layer seq (vertically 1-n1)
		// layer recs (vertically rec_count)
		// layer frames (vertically w Y h)
		// frame(1)
		// comp1 comp2 comp3 (horizontally comp_count or d)

		self->apexes = lu_arr__create(mem, self->config.apexes_size, true);
		lu__assert(self->apexes);

		return self;
	}

	static void lu_s__destroy(Lu_S self)
	{
		lu__assert(self);

		if (self->frames) lu_arr__destroy(self->frames);
		if (self->apexes) lu_arr__destroy(self->apexes);

		lu_mem__free(self->mem, (lu_p_byte) self);
	}

///////////////////////////////////////////////////////////////////////////////
// Lu_S Methods


	static void lu_s__print_info(Lu_S self)
	{
		// lu__user_assert_void(self, "Lu_S is NULL");
		// lu__user_assert_void(self->recs, "Lu_S recs is NULL");

 	// 	lu__debug("\n\n-- Lu_S info: ");
 	// 	lu__debug("\n 	Lu_S_Rec_Rg count: %lu", lu_arr__count(self->recs));

 	// 	Lu_S_Rec_Rg rec;
 	// 	lu_size i;
 	// 	for(i = 0; i < lu_arr__count(self->recs); i++)
 	// 	{
 	// 		rec = (Lu_S_Rec_Rg) lu_arr__get(self->recs, i);
 	// 		if (rec) 
 	// 			lu_s_rec_rg__print_info(rec);
 	// 	}
	}
