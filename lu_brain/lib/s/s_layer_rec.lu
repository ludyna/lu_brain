/**
	Copyright Â© 2022 Oleh Ihorovych Novosad 
*/

///////////////////////////////////////////////////////////////////////////////
// 

	static Lu_S_Layer_Rec lu_s_layer_rec__create(Lu_Config config, Lu_Rec rec, lu_size layer_ix, lu_size area_ix)
	{
		lu__assert(config);
		lu__assert(config->s_mem);
		lu__assert(config->w_mem);
		lu__assert(rec);
		lu__assert(rec->width > 0);
		lu__assert(rec->height > 0);

		Lu_S_Layer_Rec self = (Lu_S_Layer_Rec) lu_mem__alloc(config->s_mem, sizeof(struct lu_s_layer_rec));
		lu__assert(self);
		
		lu_s_layer__init(
			&self->super, 
			config,
			LU_S_LAYER__REC, // type
			layer_ix, 
			area_ix,
			rec->depth, //children
			lu_s_layer_rec__destroy,
			rec->width,
			rec->height,
			rec->height, // fixed n_table
			LU_AREA_TAG__REC
		);

		self->rec = rec;
		self->save_w_recs_size = config->w_save_waves_size;
		self->save_w_recs = (struct lu_w_rec*) lu_mem__alloc(self->super.super.w_mem, sizeof(struct lu_w_rec) * self->save_w_recs_size);
		self->match_w_recs_size = config->w_match_waves_size;
		self->match_w_recs = (struct lu_w_rec*) lu_mem__alloc(self->super.super.w_mem, sizeof(struct lu_w_rec) * self->match_w_recs_size);

		Lu_W_Rec w_rec;
		for (lu_size i = 0; i < self->save_w_recs_size; i++)
		{
			w_rec = lu_s_layer_rec__get_save_w_rec(self, i);
			lu__assert(w_rec);

			lu_w_rec__reset(w_rec);
		}

		for (lu_size i = 0; i < self->match_w_recs_size; i++)
		{
			w_rec = lu_s_layer_rec__get_match_w_rec(self, i);
			lu__assert(w_rec);

			lu_w_rec__reset(w_rec);
		}
		
		return self;	
	}

	static void lu_s_layer_rec__destroy(Lu_S_Layer_Base self)
	{
		lu__assert(self);
		lu__assert(self->s_mem);
		lu__assert(self->w_mem);
		lu__assert(self->type == LU_S_LAYER__REC);

		Lu_S_Layer_Rec layer = (Lu_S_Layer_Rec) self;

		lu_mem__free(self->w_mem, (lu_p_byte) layer->match_w_recs);
		lu_mem__free(self->w_mem, (lu_p_byte) layer->save_w_recs);

		lu__assert(layer->rec);

		lu_s_layer__deinit(&layer->super);

		lu_mem__free(self->s_mem, (lu_p_byte) self);
	}

///////////////////////////////////////////////////////////////////////////////
// 

	static Lu_W_Table lu_s_layer_rec__save(
		Lu_S_Layer_Rec self, 
		Lu_Save_Wave save_wave,
		lu_size rec_id, 
		Lu_Data data,
		Lu_Process_Config config
	)
	{
		lu__assert(self);
		lu__assert(self->rec);
		lu__assert(data);
		lu__assert(config);

		Lu_Wave wave = (Lu_Wave) save_wave;

		Lu_W_Rec w_rec = lu_s_layer_rec__get_save_w_rec(self, wave->wave_ix);
		lu__assert(w_rec);

		lu_w_rec__update(w_rec, wave->wave_id, wave->wave_ix, data->block_ix);

		#ifdef LU__DEEP_DEBUG
		char buffer[50];
		lu_w_rec_state__to_str(w_rec->state, buffer);
		lu__debug(
			"\nREC_SAVE: w_rec->state = %s, wave_id = %ld, wave_ix = %ld, block_ix = %ld", 
			buffer,
			w_rec->wave_id,
			w_rec->wave_ix,
			w_rec->block_ix
		);
		
		lu_data__print(data);
		#endif

		Lu_N_Table rec_n_table = lu_s_layer_rec__get_n_table(self);

		lu__assert(rec_n_table);

		Lu_S_Layer_Base base = (Lu_S_Layer_Base) self;

		Lu_Slot_Base slot_base = base->c;
		lu__assert(slot_base);
		lu__assert(slot_base->type == LU_SLOT__ARR);

		Lu_Slot_Arr slot_arr = (Lu_Slot_Arr) slot_base;

		lu__assert(self->rec->depth == lu_arr__count(slot_arr->items));

		lu_size block_ix = data->block_ix;

		lu_size x;
		lu_size y;
		lu_size z;
		lu_size y_shift;
		lu_value v;
		lu_size xy_shift;
		Lu_S_Layer_Comp comp;

		lu_size wh = data->h * data->w;
		Lu_S_View_P s_view_p;
		Lu_W_Table_P w_table_p;

		Lu_W_Cell_P w_cell_p;
		Lu_Comp_Calc p_comp_calc;

		Lu_W_Table curr_w_table = lu_s_layer__get_w_table(&self->super, wave->wave_ix);
		lu__assert(curr_w_table);

		curr_w_table->wave_ix = wave->wave_ix;
		curr_w_table->block_ix = block_ix;

		Lu_W_Cell rec_w_p_cell;

		// union lu_n_addr n_addr;

		lu_size depth = self->rec->depth; 

		Lu_W_Cell_P children[depth];
		
		curr_w_table->any_fired = false;

		// Lu_W_Cell_P vp_cell;

		Lu_N_Column n_column;
		Lu_N_Cell n_cell;

		for (y = 0; y < data->h; y++)
		{
			y_shift = y * data->w;

			for (x = 0; x < data->w; x++)
			{
				xy_shift = y_shift + x;

				rec_w_p_cell = lu_w_table__get_w_cell(curr_w_table, x, y);
				lu_w_cell__reset(rec_w_p_cell);

				// reset string
				children[0] = NULL;

				// Collect children
				for (z = 0; z < depth; z++)
				{
					comp = (Lu_S_Layer_Comp) lu_arr__get(slot_arr->items, z);
					lu__assert(comp->super.type == LU_S_LAYER__COMP);

					s_view_p = &comp->p_view;

					w_table_p = lu_s_view_p__get_w_save_table(s_view_p, wave->wave_ix);
					lu__assert(w_table_p);

					p_comp_calc = &s_view_p->comp_calc;
					w_cell_p = lu_w_table_p__get_w_cell_by_ix(w_table_p, xy_shift);

					if (w_rec->state == LU_W_REC_STATE__ONE || w_rec->state == LU_W_REC_STATE__START)
					{
						lu_w_cell_p__reset(w_cell_p);
					}

					// Get value from Data
					v = data->values[z * wh + xy_shift];

					lu_w_cell_p__update(
						w_cell_p,
						w_rec->state,
						v
					);

					if (w_rec->state == LU_W_REC_STATE__SWITCH || w_rec->state == LU_W_REC_STATE__TWO)
					{
						children[z] = lu_w_cell_p__save(
							w_cell_p, 
							x, 
							y, 
							p_comp_calc, 
							s_view_p->n_comp_table
						);

						lu__assert(children[z]);
					}

				} // for (lu_size z = 0

				if (w_rec->state == LU_W_REC_STATE__SWITCH || w_rec->state == LU_W_REC_STATE__TWO)
				{
					//
					// N Cell save
					//

					n_column = lu_n_table__get_column(rec_n_table, x, y);
					lu__assert(n_column);
					
					n_cell = lu_n_column__save_with_vp_children(n_column, children, z);
					lu__assert(n_cell);

					//
					// Parent W cell save
					//

					lu_w_cell__save(rec_w_p_cell, n_cell, n_column);
				}

			}  // for (x = 0
		} // for (y = 0

		#ifdef LU__DEEP_DEBUG
		if (w_rec->state == LU_W_REC_STATE__SWITCH || w_rec->state == LU_W_REC_STATE__TWO)
		{
			// Debug w_table
			for (z = 0; z < depth; z++)
			{
				comp = (Lu_S_Layer_Comp) lu_arr__get(slot_arr->items, z);
				lu__assert(comp->super.type == LU_S_LAYER__COMP);

				s_view_p = &comp->p_view;

				w_table_p = lu_s_view_p__get_w_save_table(s_view_p, wave->wave_ix);
				lu__assert(w_table_p);

				lu_w_table_p__print(w_table_p);
			}
		}	
		#endif

		if (w_rec->state == LU_W_REC_STATE__SWITCH || w_rec->state == LU_W_REC_STATE__TWO)
		{
			// Should fire for these states ONLY
			curr_w_table->any_fired = true;
		}

		return curr_w_table;
	}


	static void lu_s_layer_rec__match(
		Lu_S_Layer_Rec self, 
		Lu_Match_Wave match_wave,
		lu_size rec_id, 
		Lu_Data data,
		Lu_Process_Config config,
		Lu_W_Processor processor
	)
	{
		lu__assert(self);
		lu__assert(self->rec);
		lu__assert(data);
		lu__assert(config);

		Lu_Wave wave = (Lu_Wave) match_wave;

		Lu_W_Rec w_rec = lu_s_layer_rec__get_match_w_rec(self, wave->wave_ix);
		lu__assert(w_rec);

		lu_w_rec__update(w_rec, wave->wave_id, wave->wave_ix, data->block_ix);

		char buffer[50];
		lu_w_rec_state__to_str(w_rec->state, buffer);
		lu__debug(
			"\n\nREC_MATCH: w_rec->state = %s, wave_id = %ld, wave_ix = %ld, block_ix = %ld \n\n", 
			buffer,
			w_rec->wave_id,
			w_rec->wave_ix,
			w_rec->block_ix
		);

		Lu_N_Table rec_n_table = lu_s_layer_rec__get_n_table(self);

		lu__assert(rec_n_table);

		Lu_S_Layer_Base base = (Lu_S_Layer_Base) self;

		Lu_Slot_Base slot_base = base->c;
		lu__assert(slot_base);
		lu__assert(slot_base->type == LU_SLOT__ARR);

		Lu_Slot_Arr slot_arr = (Lu_Slot_Arr) slot_base;

		lu__assert(self->rec->depth == lu_arr__count(slot_arr->items));

		bool process_p = !lu_value__eq_with_signif(config->p_potency, 0.0, config->min_potency);
		bool process_v = false; //!lu_value__eq_with_signif(config->v_potency, 0.0, config->min_potency);

		if (!process_p && !process_v) return;

		lu_size block_ix = data->block_ix;

		lu_size x;
		lu_size y;
		lu_size z;
		lu_size y_shift;
		lu_value v;
		lu_size xy_shift;
		Lu_S_Layer_Comp comp;

		lu_size wh = data->h * data->w;

		Lu_S_View_P s_view_p;
		Lu_W_Table_P w_table_p;
		Lu_W_Cell_P w_cell_p;
		Lu_Comp_Calc p_comp_calc;

		processor->wave_id = wave->wave_id;
		processor->wave_ix = wave->wave_ix;
		processor->block_ix = block_ix;

		lu_size depth = self->rec->depth; 

		for (y = 0; y < data->h; y++)
		{
			y_shift = y * data->w;

			for (x = 0; x < data->w; x++)
			{
				xy_shift = y_shift + x;

				// Collect children, z are just "RBG"
				for (z = 0; z < depth; z++)
				{
					comp = (Lu_S_Layer_Comp) lu_arr__get(slot_arr->items, z);
					lu__assert(comp->super.type == LU_S_LAYER__COMP);

					s_view_p = &comp->p_view;

					w_table_p = lu_s_view_p__get_w_match_table(s_view_p, wave->wave_ix);
					lu__assert(w_table_p);

					p_comp_calc = &s_view_p->comp_calc;
					w_cell_p = lu_w_table_p__get_w_cell_by_ix(w_table_p, xy_shift);

					if (w_rec->state == LU_W_REC_STATE__ONE || w_rec->state == LU_W_REC_STATE__START)
					{
						lu_w_cell_p__reset(w_cell_p);
					}

					// Get value from Data
					v = data->values[z * wh + xy_shift];

					lu_w_cell_p__update(
						w_cell_p,
						w_rec->state,
						v
					);

					if (w_rec->state == LU_W_REC_STATE__SWITCH || w_rec->state == LU_W_REC_STATE__TWO)
					{
						lu_w_cell_p__save(
							w_cell_p, 
							x, 
							y, 
							p_comp_calc, 
							s_view_p->n_comp_table
						);

						// now that we have detected n_cell, we can fire it
						lu_w_processor__fire_vp_parents_with_sig(processor, w_cell_p->n_cell, w_cell_p->n_column, 1.0);
					}


				} // for (lu_size z = 0

			}  // for (x = 0
		} // for (y = 0
	}