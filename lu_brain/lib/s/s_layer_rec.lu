/**
	Copyright Â© 2022 Oleh Ihorovych Novosad 
*/

///////////////////////////////////////////////////////////////////////////////
// 

	static Lu_S_Layer_Rec lu_s_layer_rec__create(Lu_Config config, Lu_Rec rec)
	{
		lu__assert(config);
		lu__assert(config->s_mem);
		lu__assert(rec);
		lu__assert(rec->width > 0);
		lu__assert(rec->height > 0);

		Lu_S_Layer_Rec self = (Lu_S_Layer_Rec) lu_mem__alloc(config->s_mem, sizeof(struct lu_s_layer_rec));
		lu__assert(self);
		
		lu_s_layer__init(
			&self->super, 
			config,
			LU_S_LAYER__REC, // type
			1, //level
			rec->depth, //children
			lu_s_layer_rec__destroy,
			rec->width,
			rec->height * 2, /* IMPORTANT MULTIPLIER HERE */
			LU_N_CELL__N
		);

		self->rec = rec;
		
		return self;
	}

	static void lu_s_layer_rec__destroy(Lu_S_Layer_Base self)
	{
		lu__assert(self);
		lu__assert(self->s_mem);
		lu__assert(self->type == LU_S_LAYER__REC);

		Lu_S_Layer_Rec layer = (Lu_S_Layer_Rec) self;

		lu__assert(layer->rec);

		lu_s_layer__deinit(&layer->super);

		lu_mem__free(self->s_mem, (lu_p_byte) self);
	}

///////////////////////////////////////////////////////////////////////////////
// 

	static void lu_s_layer_rec__save_data(
		Lu_S_Layer_Rec self, 
		Lu_Wave wave, 
		lu_size rec_id, 
		Lu_Data data,
		Lu_Process_Config config
	)
	{
		lu__assert(self);
		lu__assert(self->rec);
		lu__assert(wave);
		lu__assert(data);
		lu__assert(config);
		lu__assert(self->super.n_table);

		Lu_S_Layer_Base base = (Lu_S_Layer_Base) self;

		Lu_Slot_Base slot_base = base->c;
		lu__assert(slot_base);
		lu__assert(slot_base->type == LU_SLOT__ARR);

		Lu_Slot_Arr slot_arr = (Lu_Slot_Arr) slot_base;

		lu__assert(self->rec->depth == lu_arr__count(slot_arr->items));

		bool save_v = !lu_value__eq_with_signif(config->v_potency, 0.0, config->min_potency);
		bool save_p = !lu_value__eq_with_signif(config->p_potency, 0.0, config->min_potency);

		lu_size wave_id = lu_wave__get_id(wave);
		lu_size block_id = data->block_id;

		lu_size x;
		lu_size y;
		lu_size y_shift;
		lu_value p;
		lu_value v;
		lu_size xy_shift;
		Lu_S_Layer_Comp comp;

		lu_size wh = data->h * data->w;

		Lu_S_View_P p_view;
		Lu_S_View_V v_view;

		Lu_W_Table_P p_table;
		Lu_W_Table_V v_table;

		lu_bool is_reset;

		Lu_W_Cell_P p_cell;
		Lu_W_Cell_V v_cell;

		Lu_Comp_Calc p_comp_calc;
		Lu_Comp_Calc v_comp_calc;

		Lu_W_Table rec_w_table = lu_s_layer__get_w_table(&self->super, wave_id);
		lu__assert(rec_w_table);

		is_reset = rec_w_table->wave_id != wave_id || ((block_id - rec_w_table->block_id) > 1);
		lu__debug("\n IS_RESET: %d ", is_reset);

		rec_w_table->wave_id = wave_id;
		rec_w_table->block_id = block_id;

		Lu_W_Cell rec_w_p_cell;
		Lu_W_Cell rec_w_v_cell;

		lu_bool v_reset;

		lu_size rec_y;

		for (y = 0; y < data->h; y++)
		{
			y_shift = y * data->w;

			lu__debug("\n");

			rec_y = y * 2;

			for (x = 0; x < data->w; x++)
			{
				xy_shift = y_shift + x;

				rec_w_p_cell = lu_w_table__get_cell(rec_w_table, x, rec_y);
				rec_w_v_cell = lu_w_table__get_cell(rec_w_table, x, rec_y + 1);

				lu_w_cell__reset(rec_w_p_cell);
				lu_w_cell__reset(rec_w_v_cell);

				for (lu_size z = 0; z < lu_arr__count(slot_arr->items); z++)
				{
					v_reset = true;

					comp = (Lu_S_Layer_Comp) lu_arr__get(slot_arr->items, z);
					lu__assert(comp->super.type == LU_S_LAYER__COMP);

					p_view = &comp->p_view;
					v_view = &comp->v_view;

					p_table = lu_s_view_p__get_w_table(p_view, wave_id);
					lu__assert(p_table);

					v_table = lu_s_view_v__get_w_table(v_view, wave_id);
					lu__assert(v_table);

					p_comp_calc = &p_view->comp_calc;
					v_comp_calc = &v_view->comp_calc;

					v = data->values[z * wh + xy_shift];
					lu__debug("	%.1f", v);

			 		p_cell = lu_w_table_p__get_cell(p_table, x, y);
			 		v_cell = lu_w_table_v__get_cell(v_table, x, y);

					lu_w_cell_p__register(p_cell, is_reset, p, config);

					if (lu_w_cell_p__is_ready(p_cell))
					{
						if (save_p)
						{
							lu_w_cell_p__save(
								p_cell, 
								x, 
								y, 
								p_comp_calc, 
								p_view->n_comp_table
							);

							lu_w_cell__collect_sig(
								rec_w_p_cell, 
								lu_n_table_comp__get_cell_ix(p_view->n_comp_table, p_cell->n_cell), 
								p_cell->sig
							);
						}

						if (save_v)
						{
							lu_w_cell_v__register(v_cell, is_reset, v, config);

							if (lu_w_cell_v__is_ready(v_cell))
							{
			 					lu_w_cell_v__save(
			 						v_cell, 
			 						x,
			 						y,
			 						v_comp_calc, 
			 						v_view->n_comp_table
			 					); 

			 					lu_w_cell__collect_sig(
			 						rec_w_v_cell, 
			 						lu_n_table_comp__get_cell_ix(p_view->n_comp_table, p_cell->n_cell), 
			 						v_cell->sig
			 					);

			 					v_reset = false;
							}
						}
					}

					if (v_reset)
						lu_w_cell_v__reset(v_cell);


				} // for (lu_size z = 0

				// 

			}  // for (x = 0
		} // for (y = 0

		// continue saving to higher levels recursively (wave)

	}