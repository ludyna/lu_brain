/**
	Copyright Â© 2022 Oleh Ihorovych Novosad 
*/

///////////////////////////////////////////////////////////////////////////////
// 

	static Lu_S_Layer_Rec lu_s_layer_rec__create(Lu_Config config, Lu_Rec rec, lu_size layer_ix, lu_size area_ix)
	{
		lu__assert(config);
		lu__assert(config->s_mem);
		lu__assert(config->w_mem);
		lu__assert(rec);
		lu__assert(rec->width > 0);
		lu__assert(rec->height > 0);

		Lu_S_Layer_Rec self = (Lu_S_Layer_Rec) lu_mem__alloc(config->s_mem, sizeof(struct lu_s_layer_rec));
		lu__assert(self);
		
		lu_s_layer__init(
			&self->super, 
			config,
			LU_S_LAYER__REC, // type
			layer_ix, 
			area_ix,
			rec->depth, //children
			lu_s_layer_rec__destroy,
			rec->width,
			rec->height,
			rec->height, // fixed n_table
			LU_AREA_TAG__REC
		);

		self->rec = rec;
		self->save_w_recs_size = config->w_save_waves_size;
		self->save_w_recs = (struct lu_w_rec*) lu_mem__alloc(self->super.super.w_mem, sizeof(struct lu_w_rec) * self->save_w_recs_size);
		self->match_w_recs_size = config->w_match_waves_size;
		self->match_w_recs = (struct lu_w_rec*) lu_mem__alloc(self->super.super.w_mem, sizeof(struct lu_w_rec) * self->match_w_recs_size);

		Lu_W_Rec w_rec;
		for (lu_size i = 0; i < self->save_w_recs_size; i++)
		{
			w_rec = lu_s_layer_rec__get_save_w_rec(self, i);
			lu__assert(w_rec);

			lu_w_rec__reset(w_rec);
		}

		for (lu_size i = 0; i < self->match_w_recs_size; i++)
		{
			w_rec = lu_s_layer_rec__get_match_w_rec(self, i);
			lu__assert(w_rec);

			lu_w_rec__reset(w_rec);
		}
		
		return self;	
	}

	static void lu_s_layer_rec__destroy(Lu_S_Layer_Base self)
	{
		lu__assert(self);
		lu__assert(self->s_mem);
		lu__assert(self->w_mem);
		lu__assert(self->type == LU_S_LAYER__REC);

		Lu_S_Layer_Rec layer = (Lu_S_Layer_Rec) self;

		lu_mem__free(self->w_mem, (lu_p_byte) layer->match_w_recs);
		lu_mem__free(self->w_mem, (lu_p_byte) layer->save_w_recs);

		lu__assert(layer->rec);

		lu_s_layer__deinit(&layer->super);

		lu_mem__free(self->s_mem, (lu_p_byte) self);
	}

///////////////////////////////////////////////////////////////////////////////
// 
	static void lu_s_layer__reset_children(Lu_W_Cell_P* children, lu_size depth)
	{
		lu__assert(children);

		for (lu_size i = 0; i < depth; i++)
		{
			children[i] = NULL;
		}
	}


///////////////////////////////////////////////////////////////////////////////
// Lu_S_Layer_Rec_Block_Params

	struct lu_s_layer_rec_block_params {
		lu_size src_start_x;
		lu_size src_start_y;
		lu_size src_start_z;

		lu_size src_end_x;
		lu_size src_end_y;
		lu_size src_end_z;

		lu_size src_x;
		lu_size src_y;

		lu_long dest_x; 
		lu_long dest_y;

		lu_long dest_start_x;
		lu_long dest_start_y;

		lu_size wave_ix;
		Lu_Data data;
		enum lu_w_rec_state state;
		Lu_W_Table curr_w_table;
		Lu_N_Table curr_n_table;

		Lu_W_Processor processor;
	};

	typedef struct lu_s_layer_rec_block_params* Lu_S_Layer_Rec_Block_Params;


	static void lu_s_layer_rec_block_params__print(Lu_S_Layer_Rec_Block_Params self)
	{
		lu__debug("\nBLOCK PARAMS PRINT:");
		lu__debug("\n\tSRC X SE [%ld,%ld]", self->src_start_x, self->src_end_x);
		lu__debug("\n\tSRC Y SE [%ld,%ld]", self->src_start_y, self->src_end_y);
		lu__debug("\n\tSRC Z SE [%ld,%ld]", self->src_start_z, self->src_end_z);
		lu__debug("\n\tSRC X,Y [%ld,%ld]", self->src_x, self->src_y);
		lu__debug("\n\tDEST X,Y [%ld,%ld]", self->dest_x, self->dest_y);
		lu__debug("\n\tDEST START X,Y [%ld,%ld]", self->dest_start_x, self->dest_start_y);
	}

///////////////////////////////////////////////////////////////////////////////
// 

	static void lu_s_layer_rec__block_collect(Lu_S_Layer_Rec self, Lu_S_Layer_Rec_Block_Params p)
	{
		Lu_S_Layer_Comp comp;
		Lu_S_View_P s_view_p;
		Lu_W_Table_P w_table_p;
		Lu_W_Cell_P w_cell_p;
		Lu_Comp_Calc p_comp_calc;
		lu_value v;

		for (lu_size src_z = p->src_start_z; src_z < p->src_end_z; src_z++)
		{
			comp = lu_s_layer_rec__get_layer_comp(self, src_z);
			lu__assert(comp);

			s_view_p = &comp->p_view;

			w_table_p = lu_s_view_p__get_w_save_table(s_view_p, p->wave_ix);
			lu__assert(w_table_p);

			p_comp_calc = &s_view_p->comp_calc;

			// write destination w_cell_p
			w_cell_p = lu_w_table_p__get_w_cell(w_table_p, p->dest_x, p->dest_y);

			lu_w_cell_p__reset(w_cell_p);

			#ifdef LU__DEEP_DEBUG

			if (p->dest_x == 3 && p->dest_y == 5)
			{
				lu__debug("\nSRC[%ld, %ld], DEST[%ld, %ld]: v=%.1f", p->src_x, p->src_y, p->dest_x, p->dest_y, v);
				lu__debug("\nCOLLECT CELL BEFORE FIRST COLLECT");
				lu_w_cell_p__print(w_cell_p);

				lu_s_layer_rec_block_params__print(p);
			}

			#endif

			// Get value from Data
			// v = data->values[src_z * wh + xy_shift];
			v = lu_data__get_value(p->data, p->src_x, p->src_y, src_z);

			lu_w_cell_p__collect(w_cell_p, v);

			#ifdef LU__DEEP_DEBUG

			if (p->dest_x == 3 && p->dest_y == 5)
			{
				lu__debug("\nCOLLECT CELL AFTER FIRST COLLECT");
				lu_w_cell_p__print(w_cell_p);
			}

			#endif
		}
	}

	static void lu_s_layer_rec__block_collect_and_save(Lu_S_Layer_Rec self, Lu_S_Layer_Rec_Block_Params p)
	{
		Lu_S_Layer_Comp comp;
		Lu_S_View_P s_view_p;
		Lu_W_Table_P w_table_p;
		Lu_W_Cell_P w_cell_p;
		Lu_Comp_Calc p_comp_calc;
		lu_value v;

		Lu_N_Column n_column;
		Lu_N_Cell n_cell;

		// write destination w_cell (not w_cell_p)
		Lu_W_Cell w_cell = lu_w_table__get_w_cell(p->curr_w_table, p->dest_x, p->dest_y);
		lu__assert(w_cell);
		lu_w_cell__reset(w_cell);

		lu_size children_count = p->src_end_z - p->src_start_z;
		Lu_W_Cell_P children[children_count];

		lu_s_layer__reset_children(children, children_count);

		// Collect children
		for (lu_size src_z = p->src_start_z; src_z < p->src_end_z; src_z++)
		{
			comp = lu_s_layer_rec__get_layer_comp(self, src_z);
			lu__assert(comp);

			s_view_p = &comp->p_view;

			w_table_p = lu_s_view_p__get_w_save_table(s_view_p, p->wave_ix);
			lu__assert(w_table_p);

			p_comp_calc = &s_view_p->comp_calc;

			// write destination w_cell_p
			w_cell_p = lu_w_table_p__get_w_cell(w_table_p, p->dest_x, p->dest_y);

			// Get value from Data
			// v = data->values[src_z * wh + xy_shift];
			v = lu_data__get_value(p->data, p->src_x, p->src_y, src_z);

			#ifdef LU__DEEP_DEBUG

			if (p->dest_x == 3 && p->dest_y == 5)
			{
				lu__debug("\nSRC[%ld, %ld], DEST[%ld, %ld]: v=%.1f", p->src_x, p->src_y, p->dest_x, p->dest_y, v);
				lu__debug("\nCOLLECT AND SHIFT: CELL BEFORE SECOND COLLECT");
				lu_w_cell_p__print(w_cell_p);
			}

			#endif

			lu_w_cell_p__collect_and_shift(w_cell_p, v);

			#ifdef LU__DEEP_DEBUG

			if (p->dest_x == 3 && p->dest_y == 5)
			{
				lu__debug("\nCOLLECT AND SHIFT: CELL AFTER SECOND COLLECT");
				lu_w_cell_p__print(w_cell_p);
			}

			#endif

			children[src_z] = lu_w_cell_p__save(
				w_cell_p, 
				p->dest_x, 
				p->dest_x, 
				p_comp_calc, 
				s_view_p->n_comp_table
			);

			lu__assert(children[src_z]);

		} // for (lu_size src_z = 0

		//
		// N Cell save
		//

		n_column = lu_n_table__get_n_column(p->curr_n_table, p->dest_x, p->dest_y);
		lu__assert(n_column);
		
		n_cell = lu_n_column__save_with_vp_children(n_column, children, children_count);
		lu__assert(n_cell);

		//
		// Parent W cell save
		//

		lu_w_cell__save(w_cell, n_cell, n_column);
		
	}

	static void lu_s_layer_rec__block_collect_and_match(Lu_S_Layer_Rec self, Lu_S_Layer_Rec_Block_Params p)
	{
		lu__assert(p->processor);

		Lu_S_Layer_Comp comp;
		Lu_S_View_P s_view_p;
		Lu_W_Table_P w_table_p;
		Lu_W_Cell_P w_cell_p;
		Lu_Comp_Calc p_comp_calc;
		lu_value v;

		Lu_N_Column n_column;
		Lu_N_Cell n_cell;

		// write destination w_cell (not w_cell_p)
		Lu_W_Cell w_cell = lu_w_table__get_w_cell(p->curr_w_table, p->dest_x, p->dest_y);
		lu__assert(w_cell);
		lu_w_cell__reset(w_cell);

		lu_size children_count = p->src_end_z - p->src_start_z;
		Lu_W_Cell_P children[children_count];

		lu_s_layer__reset_children(children, children_count);

		// Collect children
		for (lu_size src_z = p->src_start_z; src_z < p->src_end_z; src_z++)
		{
			comp = lu_s_layer_rec__get_layer_comp(self, src_z);
			lu__assert(comp);

			s_view_p = &comp->p_view;

			w_table_p = lu_s_view_p__get_w_save_table(s_view_p, p->wave_ix);
			lu__assert(w_table_p);

			p_comp_calc = &s_view_p->comp_calc;

			// write destination w_cell_p
			w_cell_p = lu_w_table_p__get_w_cell(w_table_p, p->dest_x, p->dest_y);

			// Get value from Data
			// v = data->values[src_z * wh + xy_shift];
			v = lu_data__get_value(p->data, p->src_x, p->src_y, src_z);

			lu_w_cell_p__collect_and_shift(w_cell_p, v);

			lu_w_cell_p__save(
				w_cell_p, 
				p->dest_x, 
				p->dest_x, 
				p_comp_calc, 
				s_view_p->n_comp_table
			);

			// now that we have detected n_cell, we can fire it
			lu_w_processor__fire_vp_parents_with_sig(p->processor, w_cell_p->n_cell, w_cell_p->n_column, 1.0);
			
		} // for (lu_size src_z = 0
	}

	static void lu_s_layer_rec__iterate_data_using_view(
		Lu_S_Layer_Rec self, 
		Lu_S_Layer_Rec_Block_Params p,
		void (*block)(Lu_S_Layer_Rec self, Lu_S_Layer_Rec_Block_Params p)
	)
	{
		lu__assert(self);
		lu__assert(p);
		lu__assert(block);

		Lu_Rec rec = self->rec;
		lu__assert(rec);

		Lu_W_Rec w_rec = lu_s_layer_rec__get_save_w_rec(self, p->wave_ix);
		lu__assert(w_rec);

		Lu_Rec_View rec_view = &w_rec->view;

		p->src_start_x = rec_view->src_start_x;
		p->src_start_y = rec_view->src_start_y;
		p->src_start_z = rec_view->src_start_z;

		p->src_end_x = rec_view->src_end_x;
		p->src_end_y = rec_view->src_end_y;
		p->src_end_z = rec_view->src_end_z;

		p->dest_start_x = rec_view->dest_start_x;
		p->dest_start_y = rec_view->dest_start_y;

		// Here we calculate comp=>p_view=>w_table_p=>w_cell_p with appropriante n_cell for each comp (z=1,2,3,..)
		// And then using these n_cells (saved in =>w_cell_p) we calculane n_cell in next layer and update curr_w_table with it
		for (p->src_y = p->src_start_y; p->src_y < p->src_end_y; p->src_y++)
		{
			p->dest_y = p->dest_start_y + (lu_long)(p->src_y - p->src_start_y);
			if (p->dest_y < 0) continue;
			if (p->dest_y >= rec->height) continue;

			for (p->src_x = p->src_start_x; p->src_x < p->src_end_x; p->src_x++)
			{
				p->dest_x = p->dest_start_x + (lu_long)(p->src_x - p->src_start_x);
				if (p->dest_x < 0) continue;
				if (p->dest_x >= rec->width) continue;

				//
				// Execute block
				// 

				block(self, p);

			}  // for (src_x = 0
		} // for (src_y = 0

	}

	static Lu_W_Table lu_s_layer_rec__process_data(
		Lu_S_Layer_Rec self, 
		Lu_Wave wave,
		lu_size rec_id, 
		Lu_Data data,
		Lu_Process_Config config,
		Lu_W_Processor processor,   
		void (*collect)(Lu_S_Layer_Rec self, Lu_S_Layer_Rec_Block_Params p),
		void (*collect_and_save)(Lu_S_Layer_Rec self, Lu_S_Layer_Rec_Block_Params p)
	)
	{
		lu__assert(self);
		lu__assert(wave);
		lu__assert(self->rec);
		lu__assert(data);
		lu__assert(config);;

		//
		// Update w_rec state
		//

		Lu_W_Rec w_rec = lu_s_layer_rec__get_save_w_rec(self, wave->wave_ix);
		lu__assert(w_rec);

		lu_w_rec__update(w_rec, wave->wave_id, wave->wave_ix, data->block_ix, data->view);

		#ifdef LU__DEEP_DEBUG
		char buffer[50];
		lu_w_rec_state__to_str(w_rec->state, buffer);
		lu__debug(
			"\nREC: w_state = %s, wave_id = %ld, wave_ix = %ld, block_ix = %ld, view dest pos=[%ld, %ld]", 
			buffer,
			w_rec->wave_id,
			w_rec->wave_ix,
			w_rec->block_ix,
			w_rec->view.dest_start_x,
			w_rec->view.dest_start_y
		);
		
		lu_data__print_symbols(data);
		#endif 

 		//
		// Prepare p
		//

		struct lu_s_layer_rec_block_params p;

		p.wave_ix = wave->wave_ix;
		p.data = data;
		p.state = w_rec->state;

		p.curr_n_table = lu_s_layer_rec__get_n_table(self);
		lu__assert(p.curr_n_table);

		p.curr_w_table = lu_s_layer__get_w_table(&self->super, wave->wave_ix);
		lu__assert(p.curr_w_table);

		p.processor = processor;

		//
		// Prepare curr_w_table
		//

		lu_w_table__prepare_for_wave(
			p.curr_w_table,
			wave->wave_id,
			wave->wave_ix,
			data->block_ix,
			p.curr_n_table
		);

		//
		// Because of how Rec View works we might not process all rec cells and therefore
		// not all curr_w_table cells will be set. To avoid some curr_w_table cells without n_cell/n_column or having
		// previous wave data, we reset every w_cell to appropriate n "null cells"
		//

		lu_w_table__reset_cells_to_null_cells(p.curr_w_table);
		
		//
		// Process data 
		//

		switch(p.state)
		{
			case LU_W_REC_STATE__COLLECT:
				#ifdef LU__DEEP_DEBUG
				lu_s_layer_rec__print_comp_w_tables(self, p.wave_ix, w_rec->view.src_start_z, w_rec->view.src_end_z);
				#endif

				lu_s_layer_rec__iterate_data_using_view(self, &p, collect);
				break;
			case LU_W_REC_STATE__COLLECT_AND_SAVE:
				lu_s_layer_rec__iterate_data_using_view(self, &p, collect_and_save);
				
				#ifdef LU__DEEP_DEBUG
				lu_s_layer_rec__print_comp_w_tables(self, p.wave_ix, w_rec->view.src_start_z, w_rec->view.src_end_z);
				#endif

				p.curr_w_table->any_fired = true;
				break;
			default:
				lu__assert(false);
		};

		return p.curr_w_table;
	}

	static Lu_W_Table lu_s_layer_rec__save(
		Lu_S_Layer_Rec self, 
		Lu_Save_Wave save_wave,
		lu_size rec_id, 
		Lu_Data data,
		Lu_Process_Config config
	)
	{

		return lu_s_layer_rec__process_data(
			self, 
			(Lu_Wave) save_wave,
			rec_id,
			data,
			config,
			NULL,
			lu_s_layer_rec__block_collect,
			lu_s_layer_rec__block_collect_and_save
		);
	}

	static void lu_s_layer_rec__match(
		Lu_S_Layer_Rec self, 
		Lu_Match_Wave match_wave,
		lu_size rec_id, 
		Lu_Data data,
		Lu_Process_Config config,
		Lu_W_Processor processor
	)
	{
		lu__assert(processor);

		Lu_Wave wave = (Lu_Wave) match_wave;

		//
		// Update processor
		//

		processor->wave_id = wave->wave_id;
		processor->wave_ix = wave->wave_ix;
		processor->block_ix = data->block_ix;

		//
		// Process data
		// 

		lu_s_layer_rec__process_data(
			self, 
			wave,
			rec_id,
			data,
			config,
			processor,
			lu_s_layer_rec__block_collect,
			lu_s_layer_rec__block_collect_and_match
		);

		// Lu_Wave wave = (Lu_Wave) match_wave;

		// Lu_W_Rec w_rec = lu_s_layer_rec__get_match_w_rec(self, wave->wave_ix);
		// lu__assert(w_rec);

		// lu_w_rec__update(w_rec, wave->wave_id, wave->wave_ix, data->block_ix, data->view);

		// char buffer[50];
		// lu_w_rec_state__to_str(w_rec->state, buffer);
		// lu__debug(
		// 	"\nREC_MATCH: w_rec->state = %s, wave_id = %ld, wave_ix = %ld, block_ix = %ld", 
		// 	buffer,
		// 	w_rec->wave_id,
		// 	w_rec->wave_ix,
		// 	w_rec->block_ix
		// );

		// Lu_N_Table curr_n_table = lu_s_layer_rec__get_n_table(self);

		// lu__assert(curr_n_table);

		// Lu_S_Layer_Base base = (Lu_S_Layer_Base) self;

		// Lu_Slot_Base slot_base = base->c;
		// lu__assert(slot_base);
		// lu__assert(slot_base->type == LU_SLOT__ARR);

		// Lu_Slot_Arr slot_arr = (Lu_Slot_Arr) slot_base;

		// lu__assert(self->rec->depth == lu_arr__count(slot_arr->items));

		// bool process_p = !lu_value__eq_with_signif(config->p_potency, 0.0, config->min_potency);
		// bool process_v = false; //!lu_value__eq_with_signif(config->v_potency, 0.0, config->min_potency);

		// if (!process_p && !process_v) return;

		// lu_size block_ix = data->block_ix;

		// lu_size src_x;
		// lu_size src_y;
		// lu_size src_z;
		// lu_size y_shift;
		// lu_value v;
		// lu_size xy_shift;
		// Lu_S_Layer_Comp comp;

		// lu_size wh = data->h * data->w;

		// Lu_S_View_P s_view_p;
		// Lu_W_Table_P w_table_p;
		// Lu_W_Cell_P w_cell_p;
		// Lu_Comp_Calc p_comp_calc;

		// processor->wave_id = wave->wave_id;
		// processor->wave_ix = wave->wave_ix;
		// processor->block_ix = block_ix;

		// lu_size depth = self->rec->depth; 

		// for (src_y = 0; src_y < data->h; src_y++)
		// {
		// 	y_shift = src_y * data->w;

		// 	for (src_x = 0; src_x < data->w; src_x++)
		// 	{
		// 		xy_shift = y_shift + src_x;

		// 		// Collect children, src_z are just "RBG"
		// 		for (src_z = 0; src_z < depth; src_z++)
		// 		{
		// 			comp = (Lu_S_Layer_Comp) lu_arr__get(slot_arr->items, src_z);
		// 			lu__assert(comp->super.type == LU_S_LAYER__COMP);

		// 			s_view_p = &comp->p_view;

		// 			w_table_p = lu_s_view_p__get_w_match_table(s_view_p, wave->wave_ix);
		// 			lu__assert(w_table_p);

		// 			p_comp_calc = &s_view_p->comp_calc;
		// 			w_cell_p = lu_w_table_p__get_w_cell_by_ix(w_table_p, xy_shift);

		// 			if (w_rec->state == LU_W_REC_STATE__COLLECT || w_rec->state == LU_W_REC_STATE__START)
		// 			{
		// 				lu_w_cell_p__reset(w_cell_p);
		// 			}

		// 			// Get value from Data
		// 			v = data->values[src_z * wh + xy_shift];

		// 			lu_w_cell_p__update(
		// 				w_cell_p,
		// 				w_rec->state,
		// 				v
		// 			);

		// 			if (w_rec->state == LU_W_REC_STATE__SWITCH || w_rec->state == LU_W_REC_STATE__COLLECT_AND_SAVE)
		// 			{
		// 				lu_w_cell_p__save(
		// 					w_cell_p, 
		// 					src_x, 
		// 					src_y, 
		// 					p_comp_calc, 
		// 					s_view_p->n_comp_table
		// 				);

		// 				// now that we have detected n_cell, we can fire it
		// 				lu_w_processor__fire_vp_parents_with_sig(processor, w_cell_p->n_cell, w_cell_p->n_column, 1.0);
		// 			}


		// 		} // for (lu_size src_z = 0

		// 	}  // for (src_x = 0
		// } // for (src_y = 0
	}