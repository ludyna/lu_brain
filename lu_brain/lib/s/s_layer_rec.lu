/**
	Copyright Â© 2022 Oleh Ihorovych Novosad 
*/

///////////////////////////////////////////////////////////////////////////////
// 

	static Lu_S_Layer_Rec lu_s_layer_rec__create(Lu_Config config, Lu_Rec rec, lu_size layer_ix, lu_size area_ix)
	{
		lu__assert(config);
		lu__assert(config->s_mem);
		lu__assert(rec);
		lu__assert(rec->width > 0);
		lu__assert(rec->height > 0);

		Lu_S_Layer_Rec self = (Lu_S_Layer_Rec) lu_mem__alloc(config->s_mem, sizeof(struct lu_s_layer_rec));
		lu__assert(self);
		
		lu_s_layer__init(
			&self->super, 
			config,
			LU_S_LAYER__REC, // type
			layer_ix, 
			area_ix,
			rec->depth, //children
			lu_s_layer_rec__destroy,
			rec->width,
			rec->height,
			rec->height, // fixed n_table
			LU_S_TAG__REC
		);

		self->rec = rec;
		
		return self;
	}

	static void lu_s_layer_rec__destroy(Lu_S_Layer_Base self)
	{
		lu__assert(self);
		lu__assert(self->s_mem);
		lu__assert(self->type == LU_S_LAYER__REC);

		Lu_S_Layer_Rec layer = (Lu_S_Layer_Rec) self;

		lu__assert(layer->rec);

		lu_s_layer__deinit(&layer->super);

		lu_mem__free(self->s_mem, (lu_p_byte) self);
	}

///////////////////////////////////////////////////////////////////////////////
// 

	static Lu_W_Table lu_s_layer_rec__save(
		Lu_S_Layer_Rec self, 
		lu_size wave_id,
		lu_size rec_id, 
		Lu_Data data,
		Lu_Process_Config config
	)
	{
		lu__assert(self);
		lu__assert(self->rec);
		lu__assert(data);
		lu__assert(config);


		Lu_N_Table rec_n_table = lu_s_layer_rec__get_n_table(self);

		lu__assert(rec_n_table);

		Lu_S_Layer_Base base = (Lu_S_Layer_Base) self;

		Lu_Slot_Base slot_base = base->c;
		lu__assert(slot_base);
		lu__assert(slot_base->type == LU_SLOT__ARR);

		Lu_Slot_Arr slot_arr = (Lu_Slot_Arr) slot_base;

		lu__assert(self->rec->depth == lu_arr__count(slot_arr->items));

		bool save_p = !lu_value__eq_with_signif(config->p_potency, 0.0, config->min_potency);
		bool save_v = false; //!lu_value__eq_with_signif(config->v_potency, 0.0, config->min_potency);

		if (!save_p && !save_v) return NULL;

		lu_size block_id = data->block_id;

		lu_size x;
		lu_size y;
		lu_size z;
		lu_size y_shift;
		lu_value v;
		lu_size xy_shift;
		Lu_S_Layer_Comp comp;

		lu_size wh = data->h * data->w;

		Lu_S_View_P p_view;

		Lu_W_Table_P p_table;

		lu_bool is_reset;

		Lu_W_Save_Cell_P w_p_cell;

		Lu_Comp_Calc p_comp_calc;

		Lu_W_Table curr_w_table = lu_s_layer__get_w_table(&self->super, wave_id);
		lu__assert(curr_w_table);

		is_reset = curr_w_table->wave_id != wave_id || ((block_id - curr_w_table->block_id) > 1);
		lu__debug("\n IS_RESET: %d ", is_reset);

		curr_w_table->wave_id = wave_id;
		curr_w_table->block_id = block_id;

		Lu_W_Save_Cell rec_w_p_cell;

		union lu_n_addr n_addr;

		lu_size depth = self->rec->depth; 

		// Currently we support max 4 components
		lu__assert(depth < LU_N_CELL__LINKS_MAX);

		union lu_n_addr p_links[depth + 1]; 
		lu_size p_links_i;

		// lu_size v_reg;
		// lu_size v_links[depth + 1];
		// v_links[depth] = LU_N_AREA__NULL;
		
		curr_w_table->any_fired = false;

		lu_bool any_p_fired;

		for (y = 0; y < data->h; y++)
		{
			y_shift = y * data->w;

			lu__debug("\n");

			for (x = 0; x < data->w; x++)
			{
				xy_shift = y_shift + x;

				rec_w_p_cell = lu_w_table__get_cell(curr_w_table, x, y);

				lu_w_save_cell__reset(rec_w_p_cell);

				// reset string
				p_links[0].value = 0;
				p_links_i = 0;
				any_p_fired = false;

				// iterate all layer comps and save result in rec_layer(which is also s_layer)
				for (z = 0; z < depth; z++)
				{
					comp = (Lu_S_Layer_Comp) lu_arr__get(slot_arr->items, z);
					lu__assert(comp->super.type == LU_S_LAYER__COMP);

					p_view = &comp->p_view;

					p_table = lu_s_view_p__get_w_table(p_view, wave_id);
					lu__assert(p_table);

					p_comp_calc = &p_view->comp_calc;
					w_p_cell = lu_w_table_p__get_cell(p_table, xy_shift);

					v = data->values[z * wh + xy_shift];

					lu_w_save_cell_p__register(w_p_cell, is_reset, v, config);

					//lu__debug("\n PROCESSING:	%.1f", v);

					if (!is_reset && lu_w_save_cell_p__is_ready(w_p_cell, p_comp_calc->step))
					{
						//lu__debug("\n SAVING:	%.1f", v);

						lu_w_save_cell_p__save(
							w_p_cell, 
							x, 
							y, 
							p_comp_calc, 
							p_view->n_comp_table
						);

						any_p_fired = true;

						// Always save links, even if w_p_cell havent fired
						p_links[z] = w_p_cell->n_addr;
					}
					else
					{
						p_links[z] = LU_N_ADDR__INACTIVE;  
					}



				} // for (lu_size z = 0

				// finish string with zero
				p_links[z].value = 0;

				if (any_p_fired)
				{
					lu__debug("\n SAVING N_CELL");
					
					n_addr = lu_n_table__save(rec_n_table, x, y, p_links);
					lu_w_save_cell__save(rec_w_p_cell, n_addr);

					curr_w_table->any_fired = true;
				}

			}  // for (x = 0
		} // for (y = 0

		return curr_w_table;
	}