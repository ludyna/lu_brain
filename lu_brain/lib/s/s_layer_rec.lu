/**
	Copyright Â© 2022 Oleh Ihorovych Novosad 
*/

///////////////////////////////////////////////////////////////////////////////
// 

	static Lu_S_Layer_Rec lu_s_layer_rec__create(Lu_Config config, Lu_Rec rec, lu_size layer_ix, lu_size area_ix)
	{
		lu__assert(config);
		lu__assert(config->s_mem);
		lu__assert(config->w_mem);
		lu__assert(rec);
		lu__assert(rec->width > 0);
		lu__assert(rec->height > 0);

		Lu_S_Layer_Rec self = (Lu_S_Layer_Rec) lu_mem__alloc(config->s_mem, sizeof(struct lu_s_layer_rec));
		lu__assert(self);
		
		lu_s_layer__init(
			&self->super, 
			config,
			LU_S_LAYER__REC, // type
			layer_ix, 
			area_ix,
			rec->depth, //children
			lu_s_layer_rec__destroy,
			rec->width,
			rec->height,
			rec->height, // fixed n_table
			LU_AREA_TAG__REC
		);

		self->rec = rec;
		self->save_w_recs_size = config->w_save_waves_size;
		self->save_w_recs = (struct lu_w_rec*) lu_mem__alloc(self->super.super.w_mem, sizeof(struct lu_w_rec) * self->save_w_recs_size);

		Lu_W_Rec w_rec;
		for (lu_size i = 0; i < self->save_w_recs_size; i++)
		{
			w_rec = lu_s_layer_rec__get_save_w_rec(self, i);
			lu__assert(w_rec);

			lu_w_rec__init_null(w_rec);
		}
		
		return self;	
	}

	static void lu_s_layer_rec__destroy(Lu_S_Layer_Base self)
	{
		lu__assert(self);
		lu__assert(self->s_mem);
		lu__assert(self->w_mem);
		lu__assert(self->type == LU_S_LAYER__REC);

		Lu_S_Layer_Rec layer = (Lu_S_Layer_Rec) self;

		lu_mem__free(self->w_mem, (lu_p_byte) layer->save_w_recs);

		lu__assert(layer->rec);

		lu_s_layer__deinit(&layer->super);

		lu_mem__free(self->s_mem, (lu_p_byte) self);
	}

///////////////////////////////////////////////////////////////////////////////
// 

	static Lu_W_Table lu_s_layer_rec__save(
		Lu_S_Layer_Rec self, 
		Lu_Save_Wave save_wave,
		lu_size rec_id, 
		Lu_Data data,
		Lu_Process_Config config
	)
	{
		lu__assert(self);
		lu__assert(self->rec);
		lu__assert(data);
		lu__assert(config);

		Lu_Wave wave = (Lu_Wave) save_wave;

		Lu_W_Rec w_rec = lu_s_layer_rec__get_save_w_rec(self, wave->wave_ix);
		lu__assert(w_rec);

		lu_w_rec__update(w_rec, wave->wave_id, wave->wave_ix, data->block_ix);

		char buffer[50];
		lu_w_rec_state__to_str(w_rec->state, buffer);
		lu__debug(
			"\n\nREC_SAVE: w_rec->state = %s, wave_id = %ld, wave_ix = %ld, block_ix = %ld \n\n", 
			buffer,
			w_rec->wave_id,
			w_rec->wave_ix,
			w_rec->block_ix
		);

		Lu_N_Table rec_n_table = lu_s_layer_rec__get_n_table(self);

		lu__assert(rec_n_table);

		Lu_S_Layer_Base base = (Lu_S_Layer_Base) self;

		Lu_Slot_Base slot_base = base->c;
		lu__assert(slot_base);
		lu__assert(slot_base->type == LU_SLOT__ARR);

		Lu_Slot_Arr slot_arr = (Lu_Slot_Arr) slot_base;

		lu__assert(self->rec->depth == lu_arr__count(slot_arr->items));

		lu_size block_ix = data->block_ix;

		lu_size x;
		lu_size y;
		lu_size z;
		lu_size y_shift;
		lu_value v;
		lu_size xy_shift;
		Lu_S_Layer_Comp comp;

		lu_size wh = data->h * data->w;
		Lu_S_View_P p_view;
		Lu_W_Table_P p_table;
		lu_bool is_reset;
		Lu_W_Cell_P w_p_cell;
		Lu_Comp_Calc p_comp_calc;

		Lu_W_Table curr_w_table = lu_s_layer__get_w_table(&self->super, wave->wave_ix);
		lu__assert(curr_w_table);

		is_reset = curr_w_table->wave_ix != wave->wave_ix || ((block_ix - curr_w_table->block_ix) > 1);
		// lu__debug("\n IS_RESET: %d ", is_reset);

		lu__debug("\nREC__SAVE: wave_id=%ld, wave_ix=%ld, block_ix=%ld, is_reset=%ld", wave->wave_id, wave->wave_ix, block_ix, is_reset);

		curr_w_table->wave_ix = wave->wave_ix;
		curr_w_table->block_ix = block_ix;

		Lu_W_Cell rec_w_p_cell;

		// union lu_n_addr n_addr;

		lu_size depth = self->rec->depth; 

		Lu_W_Cell_P children[depth];
		
		curr_w_table->any_fired = false;

		lu_size not_null_cells_count;
		lu_size saved_count;

		// Lu_W_Cell_P vp_cell;

		Lu_N_Column n_column;
		Lu_N_Cell n_cell;

		for (y = 0; y < data->h; y++)
		{
			y_shift = y * data->w;

			for (x = 0; x < data->w; x++)
			{
				xy_shift = y_shift + x;

				rec_w_p_cell = lu_w_table__get_w_cell(curr_w_table, x, y);
				lu_w_cell__reset(rec_w_p_cell);

				// reset string
				not_null_cells_count = 0;
				saved_count = 0;
				children[0] = NULL;

				// Collect children
				for (z = 0; z < depth; z++)
				{
					comp = (Lu_S_Layer_Comp) lu_arr__get(slot_arr->items, z);
					lu__debug_assert(comp->super.type == LU_S_LAYER__COMP);

					p_view = &comp->p_view;

					p_table = lu_s_view_p__get_w_save_table(p_view, wave->wave_ix);
					lu__debug_assert(p_table);

					p_comp_calc = &p_view->comp_calc;
					w_p_cell = lu_w_table_p__get_cell(p_table, xy_shift);

					// Get value from Data
					v = data->values[z * wh + xy_shift];

					if (is_reset)
					{
						lu_w_cell_p__reset(w_p_cell);
					}

					lu_w_cell_p__register(w_p_cell, is_reset, v, config);

					// Cell is ready after p_1 and p_2 are set, independently if sig is 0 or not
					if (lu_w_cell_p__is_ready(w_p_cell, p_comp_calc->step))
					{
						//
						// Children W cell_p save
						//

						children[z] = lu_w_cell_p__save(
							w_p_cell, 
							x, 
							y, 
							p_comp_calc, 
							p_view->n_comp_table
						);

						lu__debug_assert(children[z]);

						if (children[z]->sig > 0)
						{
							++not_null_cells_count;
						}

						++saved_count;
					}


				} // for (lu_size z = 0

				// Save all links including for non changed cells 
				if (saved_count > 0)
				{
					// children_count always equal to depth
					lu__assert(saved_count == depth);

					//
					// N Cell save
					//

					n_column = lu_n_table__get_column(rec_n_table, x, y);
					lu__assert(n_column);
					
					n_cell = lu_n_column__save_with_vp_children(n_column, children, depth, not_null_cells_count);
					lu__assert(n_cell);

					//
					// Parent W cell save
					//

					lu_w_cell__save(rec_w_p_cell, n_cell, n_column);

					curr_w_table->any_fired = true;
				}
				// else
				// {
				// 	// We reset so data from previous wave don't interfere
				// 	lu_w_cell__reset(rec_w_p_cell);
				// }


			}  // for (x = 0
		} // for (y = 0

		return curr_w_table;
	}


	static void lu_s_layer_rec__match(
		Lu_S_Layer_Rec self, 
		Lu_Match_Wave match_wave,
		lu_size rec_id, 
		Lu_Data data,
		Lu_Process_Config config,
		Lu_W_Processor processor
	)
	{
		lu__assert(self);
		lu__assert(self->rec);
		lu__assert(data);
		lu__assert(config);

		Lu_Wave wave = (Lu_Wave) match_wave;

		Lu_N_Table rec_n_table = lu_s_layer_rec__get_n_table(self);

		lu__assert(rec_n_table);

		Lu_S_Layer_Base base = (Lu_S_Layer_Base) self;

		Lu_Slot_Base slot_base = base->c;
		lu__assert(slot_base);
		lu__assert(slot_base->type == LU_SLOT__ARR);

		Lu_Slot_Arr slot_arr = (Lu_Slot_Arr) slot_base;

		lu__assert(self->rec->depth == lu_arr__count(slot_arr->items));

		bool process_p = !lu_value__eq_with_signif(config->p_potency, 0.0, config->min_potency);
		bool process_v = false; //!lu_value__eq_with_signif(config->v_potency, 0.0, config->min_potency);

		if (!process_p && !process_v) return;

		lu_size block_ix = data->block_ix;

		lu_size x;
		lu_size y;
		lu_size z;
		lu_size y_shift;
		lu_value v;
		lu_size xy_shift;
		Lu_S_Layer_Comp comp;

		lu_size wh = data->h * data->w;

		Lu_S_View_P p_view;
		Lu_W_Table_P p_table;
		lu_bool is_reset;
		Lu_W_Cell_P w_p_cell;
		Lu_Comp_Calc p_comp_calc;

		is_reset = processor->wave_ix != wave->wave_ix || ((block_ix - processor->block_ix) > 1);
		lu__debug("\n IS_RESET: %d ", is_reset);

		processor->wave_id = wave->wave_id;
		processor->wave_ix = wave->wave_ix;
		processor->block_ix = block_ix;

		lu_size depth = self->rec->depth; 

		for (y = 0; y < data->h; y++)
		{
			y_shift = y * data->w;

			for (x = 0; x < data->w; x++)
			{
				xy_shift = y_shift + x;

				// Collect children, z are just "RBG"
				for (z = 0; z < depth; z++)
				{
					comp = (Lu_S_Layer_Comp) lu_arr__get(slot_arr->items, z);
					lu__debug_assert(comp->super.type == LU_S_LAYER__COMP);

					p_view = &comp->p_view;

					p_table = lu_s_view_p__get_w_match_table(p_view, wave->wave_ix);
					lu__debug_assert(p_table);

					p_comp_calc = &p_view->comp_calc;
					w_p_cell = lu_w_table_p__get_cell(p_table, xy_shift);

					// Get value from Data
					v = data->values[z * wh + xy_shift];

					if (is_reset)
					{
						lu_w_cell_p__reset(w_p_cell);
					}

					lu_w_cell_p__register(w_p_cell, is_reset, v, config);

					// Cell is ready after p_1 and p_2 are set, independently if sig is 0 or not
					if (lu_w_cell_p__is_ready(w_p_cell, p_comp_calc->step))
					{
						lu_w_cell_p__save(
							w_p_cell, 
							x, 
							y, 
							p_comp_calc, 
							p_view->n_comp_table
						);

						// now that we have detected n_cell, we can fire it
						lu_w_processor__fire_vp_parents_with_sig(processor, w_p_cell->n_cell, w_p_cell->n_column, 1.0);
					}


				} // for (lu_size z = 0

			}  // for (x = 0
		} // for (y = 0
	}