/**
	Copyright Â© 2022 Oleh Ihorovych Novosad 
*/

///////////////////////////////////////////////////////////////////////////////
// 

	static Lu_S_Layer_Comp lu_s_layer_comp__create(
		Lu_Config config, 
		Lu_S_Layer_Rec frame, 
		Lu_Rec_Comp_Config rc_config
	)
	{
		lu__assert(config);
		lu__assert(frame);
		lu__assert(rc_config);

		Lu_S_Layer_Comp self = (Lu_S_Layer_Comp) lu_mem__alloc(config->s_mem, sizeof(struct lu_s_layer_comp));
		lu__assert(self);

		lu_s_layer_base__init(
			&self->super, 
			(Lu_S_Layer_Base)frame,
			config,
			LU_S_LT__COMP,
			0,
			lu_s_layer_comp__destroy
		);

		Lu_Rec rec = frame->rec;
		lu__assert(rec);

		lu_s_view_p__init(
			&self->p_view, 
			config,
			LU_S_CVT__P, 
			rec->width, 
			rec->height, 
			rc_config->v_min, 
			rc_config->v_max, 
			rc_config->p_neu_size
		);

		lu_s_view_v__init(
			&self->v_view, 
			config, 
			LU_S_CVT__V, 
			rec->width, 
			rec->height, 
			rc_config->v_min, 
			rc_config->v_max, 
			rc_config->v_neu_size
		);

		return self;
	}

	static void lu_s_layer_comp__destroy(Lu_S_Layer_Base self)
	{
		lu__assert(self);
		lu__assert(self->s_mem);
		lu__assert(self->type == LU_S_LT__COMP);

		Lu_S_Layer_Comp layer_comp = (Lu_S_Layer_Comp) self;

		lu_s_view_p__deinit(&layer_comp->p_view);
		lu_s_view_v__deinit(&layer_comp->v_view);

		lu_s_layer_base__deinit(self);

		lu_mem__free(self->s_mem, (lu_p_byte) self);
	}

///////////////////////////////////////////////////////////////////////////////
// 
	
	static void lu_s_layer_comp__save_data(
		Lu_S_Layer_Comp self, 
		Lu_Wave wave, 
		lu_size z, 
		Lu_Data data, 
		Lu_Process_Config config
	)
	{
		lu__assert(self);
		lu__assert(wave);
		lu__assert(data);
		lu__assert(z < data->d);
		lu__assert(config);

		bool save_v = !lu_value__eq_with_signif(config->v_potency, 0.0, config->min_potency);
		bool save_p = !lu_value__eq_with_signif(config->p_potency, 0.0, config->min_potency);

		lu_size wave_id = lu_wave__get_id(wave);
		lu_size block_id = data->block_id;

		Lu_S_View_P p_view = &self->p_view;
		Lu_S_View_V v_view = &self->v_view;

		Lu_W_Table_P p_table = lu_s_view_p__get_w_table(p_view, wave_id);
		lu__assert(p_table);

		Lu_W_Table_V v_table = lu_s_view_v__get_w_table(v_view, wave_id);
		lu__assert(v_table);

		lu_size z_shift = z * data->w * data->h;

		lu_size x;
		lu_size y;
		lu_size zy_shift;
		lu_value p;
		lu_value v;
		lu_size ix;

		// mozhlyvo potribno bude she block_id, ale ne vpevnenyy, pobachymo
		// treba vynysty check wave_id = wave_id i block_id = block_id na riven 
		// p_table i v_table

		// koroche tut mozhe buty lyshe dva rezhyma na rivni table: abo my nakopychuyemo abo ce povnyy reset

		lu_bool is_reset = !(p_table->wave_id == wave_id && p_table->block_id == block_id);

		p_table->wave_id = wave_id;
		p_table->block_id = block_id;

		Lu_W_Cell_P p_cell;
		Lu_W_Cell_V v_cell;

		for (y = 0; y < data->h; y++)
		{
			zy_shift = z_shift + y * data->w;

			lu__debug("\n");

			for (x = 0; x < data->w; x++)
			{
				ix = zy_shift + x;

				v = data->values[ix];
				lu__debug("	%.1f", v);

		 		p_cell = lu_w_table_p__get_cell(p_table, x, y);

				lu_w_cell_p__register(p_cell, is_reset, p, config);

				if (lu_w_cell_p__is_ready(p_cell))
				{
					if (save_p) lu_w_cell_p__save(p_cell, &p_view->comp_calc, config);

					if (save_v)
					{
						v_cell = lu_w_table_v__get_cell(v_table, x, y);

						lu_w_cell_v__register(v_cell, is_reset, v, config);

						if (lu_w_cell_v__is_ready(v_cell))
						{
		 					lu_w_cell_v__save(v_cell, &v_view->comp_calc, config);
						}
					}
				}

			}  // for (x = 0
		} // for (y = 0

	}